diff -r cc8bd7a5eafb rosh/manifest.xml
--- a/rosh/manifest.xml	Thu Mar 15 10:37:46 2012 -0700
+++ b/rosh/manifest.xml	Tue Jun 12 15:24:41 2012 -0700
@@ -19,6 +19,7 @@
   <depend package="rosservice"/>
   <depend package="rosparam"/>
   <depend package="rosmsg"/>
+  <depend package="roslib_electric"/>
 
   <rosdep name="ipython" />
 
diff -r cc8bd7a5eafb rosh/src/rosh/__init__.py
--- a/rosh/src/rosh/__init__.py	Thu Mar 15 10:37:46 2012 -0700
+++ b/rosh/src/rosh/__init__.py	Tue Jun 12 15:24:41 2012 -0700
@@ -76,7 +76,7 @@
 from rosh.impl.bag import Bag
 
 from rosh.impl.service import Service
-from roslaunch.core import Node
+# from roslaunch.core import Node
 
 def kill(obj):
     if hasattr(obj, '_kill'):
diff -r cc8bd7a5eafb rosh/src/rosh/impl/launch.py
--- a/rosh/src/rosh/impl/launch.py	Thu Mar 15 10:37:46 2012 -0700
+++ b/rosh/src/rosh/impl/launch.py	Tue Jun 12 15:24:41 2012 -0700
@@ -42,7 +42,7 @@
 import os
 import sys
 
-import roslib.packages
+import roslib_electric.packages
 import roslaunch
 
 import rosh.impl.proc
diff -r cc8bd7a5eafb rosh/src/rosh/impl/msg.py
--- a/rosh/src/rosh/impl/msg.py	Thu Mar 15 10:37:46 2012 -0700
+++ b/rosh/src/rosh/impl/msg.py	Tue Jun 12 15:24:41 2012 -0700
@@ -36,7 +36,8 @@
 
 import sys
 
-import roslib.packages
+import roslib_electric.packages
+import roslib_electric.srvs
 import rospy
 
 import rosmsg
@@ -87,7 +88,7 @@
         elif key in self._msg_cache:
             return self._msg_cache[key]
         else:
-            if self._config.mode == roslib.msgs.EXT:
+            if self._config.mode == roslib_electric.msgs.EXT:
                 v = self._type = get_message_class(self._ns + key)
             else:
                 v = self._type = get_service_class(self._ns + key)
@@ -96,9 +97,9 @@
             return v
 
 def get_message_class(type_name):
-    val = roslib.message.get_message_class(type_name, reload_on_error=True)
+    val = roslib_electric.message.get_message_class(type_name, reload_on_error=True)
     if not val:
-        pkg, base_type = roslib.names.package_resource_name(type_name)
+        pkg, base_type = roslib_electric.names.package_resource_name(type_name)
         if '(' not in type_name:
             # ipython has an introspection bug where it forwards the
             # actual method call to the getattr.
@@ -110,9 +111,9 @@
         return val
 
 def get_service_class(type_name):
-    val = roslib.message.get_service_class(type_name, reload_on_error=True)
+    val = roslib_electric.message.get_service_class(type_name, reload_on_error=True)
     if not val:
-        pkg, base_type = roslib.names.package_resource_name(type_name)
+        pkg, base_type = roslib_electric.names.package_resource_name(type_name)
         if '(' not in type_name:
             # ipython has an introspection bug where it forwards the
             # actual method call to the getattr.
@@ -127,7 +128,7 @@
 
     def __init__(self, ctx, lock):
         super(Msgs, self).__init__(ctx, lock, MsgPackage)
-        self._config.mode = roslib.msgs.EXT
+        self._config.mode = roslib_electric.msgs.EXT
 
     def __contains__(self, key):
         """
@@ -146,7 +147,7 @@
 
     def __init__(self, ctx, lock):
         super(Srvs, self).__init__(ctx, lock, MsgPackage)
-        self._config.mode = roslib.srvs.EXT
+        self._config.mode = roslib_electric.srvs.EXT
 
     def __contains__(self, key):
         """
diff -r cc8bd7a5eafb rosh/src/rosh/impl/packages.py
--- a/rosh/src/rosh/impl/packages.py	Thu Mar 15 10:37:46 2012 -0700
+++ b/rosh/src/rosh/impl/packages.py	Tue Jun 12 15:24:41 2012 -0700
@@ -38,10 +38,10 @@
 import stat
 import sys
 
-import roslib.manifest
-import roslib.packages
-import roslib.stack_manifest
-import roslib.stacks
+import roslib_electric.manifest
+import roslib_electric.packages
+import roslib_electric.stack_manifest
+import roslib_electric.stacks
 
 # TODO: get rid of Namespace and Concept entirely as that really doesn't apply here and just requires workarounds
 from rosh.impl.namespace import Namespace, Concept, ResourceList
@@ -96,10 +96,10 @@
         super(Package, self).__init__(name, config)
 
     def _get_path(self):
-        return roslib.packages.get_pkg_dir(self.name)
+        return roslib_electric.packages.get_pkg_dir(self.name)
 
     def _get_manifest(self, path):
-        return roslib.manifest.parse_file(os.path.join(path, roslib.manifest.MANIFEST_FILE))
+        return roslib_electric.manifest.parse_file(os.path.join(path, roslib_electric.manifest.MANIFEST_FILE))
 
     def _get_msgs(self):
         try:
@@ -208,7 +208,7 @@
         
 # TODO: move into roslib for ROS 1.4. Right now rosh is targetting ROS 1.2 compatibility
 def list_resources(pkg, filter_fn):
-    return list_resources_by_dir(roslib.packages.get_pkg_dir(pkg), filter_fn)
+    return list_resources_by_dir(roslib_electric.packages.get_pkg_dir(pkg), filter_fn)
 def list_resources_by_dir(pkg_dir, filter_fn):
     resources = []
     for p, dirs, files in os.walk(pkg_dir):
@@ -227,14 +227,14 @@
         super(Stack, self).__init__(name, config)
 
     def _get_path(self):
-        return roslib.stacks.get_stack_dir(self.name)
+        return roslib_electric.stacks.get_stack_dir(self.name)
 
     def _get_manifest(self, path):
-        return roslib.stack_manifest.parse_file(os.path.join(path, roslib.stack_manifest.STACK_FILE))
+        return roslib_electric.stack_manifest.parse_file(os.path.join(path, roslib_electric.stack_manifest.STACK_FILE))
 
     def _get_packages(self):
         # we have to use the config from packages in order to get access to its cache
-        return ResourceList(self._config.ctx.packages._config, roslib.stacks.packages_of(self.name), Package)
+        return ResourceList(self._config.ctx.packages._config, roslib_electric.stacks.packages_of(self.name), Package)
 
     packages = property(_get_packages)
 
@@ -294,9 +294,9 @@
 class Packages(ManifestResources):
 
     def __init__(self, ctx, lock,):
-        super(Packages, self).__init__(ctx, lock, Package, roslib.packages.list_pkgs)
+        super(Packages, self).__init__(ctx, lock, Package, roslib_electric.packages.list_pkgs)
 
 class Stacks(ManifestResources):
 
     def __init__(self, ctx, lock):
-        super(Stacks, self).__init__(ctx, lock, Stack, roslib.stacks.list_stacks)
+        super(Stacks, self).__init__(ctx, lock, Stack, roslib_electric.stacks.list_stacks)
diff -r cc8bd7a5eafb rosh/src/rosh/impl/proc.py
--- a/rosh/src/rosh/impl/proc.py	Thu Mar 15 10:37:46 2012 -0700
+++ b/rosh/src/rosh/impl/proc.py	Tue Jun 12 15:24:41 2012 -0700
@@ -43,7 +43,8 @@
 from subprocess import Popen, PIPE
 
 import roslib.rosenv
-import roslaunch
+# import roslaunch
+
 
 # TODO: get rid of this routine or replace with Exec
 def run(config, cmd, stdout=True):
diff -r cc8bd7a5eafb rosh/src/rosh/impl/ros_graph.py
--- a/rosh/src/rosh/impl/ros_graph.py	Thu Mar 15 10:37:46 2012 -0700
+++ b/rosh/src/rosh/impl/ros_graph.py	Tue Jun 12 15:24:41 2012 -0700
@@ -35,7 +35,7 @@
 import rosgraph.masterapi
 
 import rosh.plugin
-from rosh.impl.launch import launch_symbols
+# from rosh.impl.launch import launch_symbols
 from rosh.impl.namespace import Namespace
 from rosh.impl.node import Nodes
 from rosh.impl.param import Parameters
@@ -126,7 +126,7 @@
         # Load topic tools
         _loaded_symbols.update(topic_tools_symbols(ctx))
         # Load roslaunch
-        _loaded_symbols.update(launch_symbols(ctx))
+        # _loaded_symbols.update(launch_symbols(ctx))
         
         # save these symbols in the context
         ctx.msg = _loaded_symbols['msg']
diff -r cc8bd7a5eafb roshlaunch/src/roslaunch/core.py
--- a/roshlaunch/src/roslaunch/core.py	Thu Mar 15 10:37:46 2012 -0700
+++ b/roshlaunch/src/roslaunch/core.py	Tue Jun 12 15:24:41 2012 -0700
@@ -43,11 +43,11 @@
 
 import roslib.names 
 import roslib.network
-import roslib.substitution_args
+import roslib_electric.substitution_args
 import roslib.rosenv
 
 #TODO:temporary until xacro is ported after next ROS stable release
-resolve_args = roslib.substitution_args.resolve_args
+resolve_args = roslib_electric.substitution_args.resolve_args
 
 class RLException(Exception):
     """Base roslaunch exception type"""
diff -r cc8bd7a5eafb roshlaunch/src/roslaunch/xmlloader.py
--- a/roshlaunch/src/roslaunch/xmlloader.py	Thu Mar 15 10:37:46 2012 -0700
+++ b/roshlaunch/src/roslaunch/xmlloader.py	Tue Jun 12 15:24:41 2012 -0700
@@ -46,14 +46,14 @@
 from xml.dom import Node as DomNode #avoid aliasing
 
 from roslib.names import make_global_ns, ns_join, is_global, is_private, PRIV_NAME
-import roslib.substitution_args
+import roslib_electric.substitution_args
 
 from roslaunch.core import Param, Node, Test, Machine, RLException, get_ros_package_path
 import roslaunch.loader
 
 # use in our namespace
-SubstitutionException = roslib.substitution_args.SubstitutionException
-ArgException = roslib.substitution_args.ArgException
+SubstitutionException = roslib_electric.substitution_args.SubstitutionException
+ArgException = roslib_electric.substitution_args.ArgException
 
 NS='ns'
 CLEAR_PARAMS='clear_params'
@@ -151,11 +151,11 @@
 
     def resolve_args(self, args, context):
         """
-        Wrapper around roslib.substitution_args.resolve_args to set common parameters
+        Wrapper around roslib_electric.substitution_args.resolve_args to set common parameters
         """
         # resolve_args gets called a lot, so we optimize by testing for dollar sign before resolving
         if args and '$' in args:
-            return roslib.substitution_args.resolve_args(args, context=context.resolve_dict, resolve_anon=self.resolve_anon)
+            return roslib_electric.substitution_args.resolve_args(args, context=context.resolve_dict, resolve_anon=self.resolve_anon)
         else:
             return args
 
@@ -267,7 +267,7 @@
             
             context.add_arg(name, value=value, default=default)
 
-        except roslib.substitution_args.ArgException, e:
+        except roslib_electric.substitution_args.ArgException, e:
             raise XmlParseException(
                 "arg '%s' is not defined. \n\nArg xml is %s"%(e, tag.toxml()))
         except Exception, e:
diff -r cc8bd7a5eafb roslib_electric/CMakeLists.txt
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/CMakeLists.txt	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,17 @@
+if(ROSBUILD)
+  # this is for rosbuild2 integration, you can ignore this
+  include(rosbuild.cmake OPTIONAL)
+  return()
+endif()
+cmake_minimum_required(VERSION 2.4.6)
+include($ENV{ROS_ROOT}/core/rosbuild/rosbuild.cmake)
+rosbuild_init()
+
+rosbuild_add_boost_directories()
+
+rosbuild_add_library(roslib src/package.cpp)
+rosbuild_link_boost(roslib thread)
+
+if (NOT APPLE)
+target_link_libraries(roslib rt)
+endif (NOT APPLE)
diff -r cc8bd7a5eafb roslib_electric/Makefile
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/Makefile	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,1 @@
+include $(shell rospack find mk)/cmake.mk
diff -r cc8bd7a5eafb roslib_electric/epydoc.config
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/epydoc.config	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,9 @@
+[epydoc]
+name: roslib
+modules: roslib
+inheritance: included
+url: http://ros.org/wiki/rospy
+frames: yes
+private: no
+exclude: roslib.msg
+
diff -r cc8bd7a5eafb roslib_electric/mainpage.dox
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/mainpage.dox	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,18 @@
+/**
+\mainpage
+\htmlinclude manifest.html
+
+
+\b %roslib is the base library support for ROS <a href="http://ros.org/wiki/Client Libraries">client implementations</a> as well as ROS tools. It includes:
+
+- common message definitions used in ROS clients (e.g. Header)
+- a Python library for manipulating ROS system resources (e.g. .msg files, names)
+- message and services generation callout scripts
+
+\section codeapi Code API
+
+- Time-related: ros::Time, ros::Duration, ros::Rate, ros::WallTime, ros::WallDuration, ros::WallRate.  Also see the <a href="http://ros.org/wiki/roscpp/Overview/Time">roscpp Time overview</a>.
+- Package-related: ros::package namespace
+- Debug-related: ros::debug namespace
+
+*/
diff -r cc8bd7a5eafb roslib_electric/manifest.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/manifest.xml	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,35 @@
+<package>
+  <description brief="ROS base library">
+
+      Base dependencies and support libraries for ROS. roslib contains many of the common data structures and tools that are shared across ROS client library implementations. 
+
+  </description>
+  <author>Ken Conley/kwc@willowgarage.com, Morgan Quigley/mquigley@cs.stanford.edu, Josh Faust/jfaust@willowgarage.com</author>
+  <license>BSD</license>
+  <review status="Doc reviewed" notes="2010/01/12"/>
+  <url>http://ros.org/wiki/roslib</url>
+  <export>
+    <cpp cflags="-I${prefix}/msg_gen/cpp/include -I${prefix}/include `rosboost-cfg --cflags`" lflags="-Wl,-rpath,${prefix}/lib -L${prefix}/lib -lroslib"/>
+    <rosdoc config="${prefix}/rosdoc.yaml" />
+  </export>
+  <depend package="rospack"/>
+
+  <!-- for roslib.params -->
+  <rosdep name="python"/>
+  <rosdep name="python-yaml"/>
+  
+  <rosdep name="boost"/>
+  
+  <platform os="ubuntu" version="9.04"/>
+  <platform os="ubuntu" version="9.10"/>
+  <platform os="ubuntu" version="10.04"/>
+  <platform os="macports" version="macports"/>
+  <rosbuild2> 
+    <depend package="rospack"/>
+    <depend package="cpp_common"/>
+    <export>
+      <include_dir>${roslib_SOURCE_DIR}/include</include_dir>
+      <lib>roslib</lib>
+    </export>
+  </rosbuild2>
+</package>
diff -r cc8bd7a5eafb roslib_electric/rosdoc.yaml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/rosdoc.yaml	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,7 @@
+ - builder: epydoc
+   output_dir: python
+   config: epydoc.config   
+ - builder: doxygen
+   name: C++ API
+   output_dir: c++
+   file_patterns: '*.c *.cpp *.h *.cc *.hh *.dox'
\ No newline at end of file
diff -r cc8bd7a5eafb roslib_electric/scripts/pythontest
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/scripts/pythontest	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,12 @@
+#!/bin/sh
+if [ ! -f /usr/bin/python ] ; then
+  exit 1
+fi
+
+/usr/bin/env python -c "import sys, os; os._exit(float(sys.version[:3])>=2.4);"
+if [ $? -eq 0 ]
+then
+  exit 1
+else
+  exit 0
+fi
diff -r cc8bd7a5eafb roslib_electric/src/package.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/src/package.cpp	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2009, Willow Garage, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *   * Neither the names of Stanford University or Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived from
+ *     this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "ros/package.h"
+#include "rospack/rospack.h"
+
+#include <cstdio>
+#include <iostream>
+
+#include <boost/algorithm/string/split.hpp>
+#include <boost/algorithm/string/join.hpp>
+#include <boost/algorithm/string/classification.hpp>
+#include <boost/thread/mutex.hpp>
+
+namespace ros
+{
+namespace package
+{
+
+// Mutex used to lock calls into librospack, which is not thread-safe.
+static boost::mutex librospack_mutex;
+
+std::string command(const std::string& _cmd)
+{
+  boost::mutex::scoped_lock lock(librospack_mutex);
+
+  rospack::ROSPack rp;
+  int ret;
+  try
+  {
+    ret = rp.run(_cmd);
+    if(ret == 0)
+      return rp.getOutput();
+    else {
+      if ( !rp.is_quiet() )
+	std::cerr << "ROSPack::run returned non-zero." << std::endl;
+    }
+  }
+  catch(std::runtime_error &e)
+  {
+    if ( !rp.is_quiet() )
+      std::cerr << "[rospack] " << e.what() << std::endl;
+  }
+  return std::string("");
+}
+
+void command(const std::string& cmd, V_string& output)
+{
+  std::string out_string = command(cmd);
+  V_string full_list;
+  boost::split(full_list, out_string, boost::is_any_of("\r\n"));
+
+  // strip empties
+  V_string::iterator it = full_list.begin();
+  V_string::iterator end = full_list.end();
+  for (; it != end; ++it)
+  {
+    if (!it->empty())
+    {
+      output.push_back(*it);
+    }
+  }
+}
+
+std::string getPath(const std::string& package_name)
+{
+  std::string path = command("find " + package_name);
+
+  // scrape any newlines out of it
+  for (size_t newline = path.find('\n'); newline != std::string::npos;
+              newline = path.find('\n'))
+  {
+    path.erase(newline, 1);
+  }
+
+  return path;
+}
+
+bool getAll(V_string& packages)
+{
+  command("list-names", packages);
+
+  return true;
+}
+
+void getPlugins(const std::string& package, const std::string& attribute, V_string& plugins)
+{
+  M_string plugins_map;
+  getPlugins(package, attribute, plugins_map);
+  M_string::iterator it = plugins_map.begin();
+  M_string::iterator end = plugins_map.end();
+  for (; it != end; ++it)
+  {
+    plugins.push_back(it->second);
+  }
+}
+
+void getPlugins(const std::string& package, const std::string& attribute, M_string& plugins)
+{
+  V_string lines;
+  command("plugins --attrib=" + attribute + " " + package, lines);
+
+  V_string::iterator it = lines.begin();
+  V_string::iterator end = lines.end();
+  for (; it != end; ++it)
+  {
+    V_string tokens;
+    boost::split(tokens, *it, boost::is_any_of(" "));
+
+    if (tokens.size() >= 2)
+    {
+      std::string package = tokens[0];
+      std::string rest = boost::join(V_string(tokens.begin() + 1, tokens.end()), " ");
+      plugins[package] = rest;
+    }
+  }
+}
+
+} // namespace package
+} // namespace ros
diff -r cc8bd7a5eafb roslib_electric/src/ros/__init__.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/src/ros/__init__.py	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,62 @@
+# Software License Agreement (BSD License)
+#
+# Copyright (c) 2008, Willow Garage, Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+#  * Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#  * Redistributions in binary form must reproduce the above
+#    copyright notice, this list of conditions and the following
+#    disclaimer in the documentation and/or other materials provided
+#    with the distribution.
+#  * Neither the name of Willow Garage, Inc. nor the names of its
+#    contributors may be used to endorse or promote products derived
+#    from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+# Revision $Id: __init__.py 3544 2009-01-24 00:09:21Z sfkwc $
+
+## The ros module enables dynamic importing of any ROS python module.
+## The common syntax is 'from ros import foo', where foo is a ROS package
+## name.
+
+import sys
+
+import roslib
+
+## @internal
+class Module(object):
+    def __init__(self, wrapped):
+        self.wrapped = wrapped
+
+    def __getattr__(self, name):
+        try:
+            return getattr(self.wrapped, name)
+        except AttributeError:
+            import roslib.packages
+            try:
+                roslib.load_manifest(name.split('.')[0])
+            except roslib.packages.InvalidROSPkgException as e:
+                raise ImportError("Cannot import module '%s': \n%s"%(name, str(e)))
+            return __import__(name)
+
+## rewrite our own entry in sys.modules so that dynamic loading
+## works.
+sys.modules[__name__] = Module(sys.modules[__name__])
+
diff -r cc8bd7a5eafb roslib_electric/src/roslib_electric/__init__.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/src/roslib_electric/__init__.py	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,55 @@
+# Software License Agreement (BSD License)
+#
+# Copyright (c) 2008, Willow Garage, Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+#  * Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#  * Redistributions in binary form must reproduce the above
+#    copyright notice, this list of conditions and the following
+#    disclaimer in the documentation and/or other materials provided
+#    with the distribution.
+#  * Neither the name of Willow Garage, Inc. nor the names of its
+#    contributors may be used to endorse or promote products derived
+#    from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+# Revision $Id: __init__.py 14272 2011-07-12 21:56:56Z kwc $
+
+"""
+roslib has a very important role in all Python code written for ROS:
+it contains the L{load_manifest()} method, which updates the
+PYTHONPATH based on a set of ROS Package manifest.xml files. Because
+of this role, roslib is required to be on the PYTHONPATH of every ROS
+installation.
+
+Beyond the important load_manifest() call, most of the rest of roslib
+consists of low-level libraries that 99% of ROS users need not
+interact with. These libraries are primarily to support higher-level
+ROS Python libraries, such as the rospy client library, as well as
+numerous ROS tools (e.g. rostopic).
+
+"""
+
+# from roslib_electric.launcher import load_manifest
+from roslib_electric.scriptutil import is_interactive, set_interactive
+
+# this import is necessary due to a bug in purge_build.py in our
+# debian assets.
+import roslib_electric.stacks
diff -r cc8bd7a5eafb roslib_electric/src/roslib_electric/exceptions.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/src/roslib_electric/exceptions.py	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,44 @@
+# Software License Agreement (BSD License)
+#
+# Copyright (c) 2009, Willow Garage, Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+#  * Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#  * Redistributions in binary form must reproduce the above
+#    copyright notice, this list of conditions and the following
+#    disclaimer in the documentation and/or other materials provided
+#    with the distribution.
+#  * Neither the name of Willow Garage, Inc. nor the names of its
+#    contributors may be used to endorse or promote products derived
+#    from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+# Revision $Id: exceptions.py 6490 2009-10-12 21:26:50Z kwc $
+# $Author: kwc $
+
+"""
+Provides the L{ROSLibException} class, which is common to many roslib libraries.
+"""
+
+class ROSLibException(Exception):
+    """
+    Base class for exceptions in roslib    
+    """
+    pass
diff -r cc8bd7a5eafb roslib_electric/src/roslib_electric/launcher.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/src/roslib_electric/launcher.py	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,139 @@
+#! /usr/bin/env python
+# Software License Agreement (BSD License)
+#
+# Copyright (c) 2008, Willow Garage, Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+#  * Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#  * Redistributions in binary form must reproduce the above
+#    copyright notice, this list of conditions and the following
+#    disclaimer in the documentation and/or other materials provided
+#    with the distribution.
+#  * Neither the name of Willow Garage, Inc. nor the names of its
+#    contributors may be used to endorse or promote products derived
+#    from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+# Revision $Id: launcher.py 14291 2011-07-13 03:24:43Z kwc $
+# $Author: kwc $
+
+"""
+Python path loader for python scripts and applications. Paths are
+derived from dependency structure declared in ROS manifest files.
+"""
+
+import sys
+import os
+
+import roslib_electric.manifest
+import roslib_electric.packages
+
+def get_manifest_file(package_name):
+    """
+    @return: name of package to get manifest for
+    @rtype: str
+    @raise InvalidROSPkgException: if required is True and package cannot be located
+    """
+    return roslib_electric.manifest.manifest_file(package_name, required=True)
+        
+# bootstrapped keeps track of which packages we've loaded so we don't update the path multiple times
+_bootstrapped = []
+
+def load_manifest(package_name, bootstrap_version="0.7"):
+    """
+    Update the Python sys.path with package's dependencies
+    @param package_name: name of the package that load_manifest() is being called from.
+    @type  package_name: str
+    @param bootstrap_version: (keyword argument) do not use. Soon to be deprecated
+    @type  bootstrap_version: str
+    """
+    if package_name in _bootstrapped:
+        return
+    prefix = []
+    if 'ROS_BUILD' in os.environ:
+        if os.environ['ROS_BUILD'] == os.environ['ROS_ROOT']:
+            return
+        prefix = [os.path.join(os.environ['ROS_BUILD'], 'gen', 'py'),
+                  os.path.join(os.environ['ROS_BUILD'], '..', 'rosidl', 'src')]
+    sys.path = prefix + _generate_python_path(package_name, [], os.environ) + sys.path
+    
+def _append_package_paths(manifest_, paths, pkg_dir):
+    """
+    Added paths for package to paths
+    @param manifest_: package manifest
+    @type  manifest_: Manifest
+    @param pkg_dir: package's filesystem directory path
+    @type  pkg_dir: str
+    @param paths: list of paths
+    @type  paths: [str]
+    """
+    exports = manifest_.get_export('python','path')
+    if exports:
+        for export in exports:
+            if ':' in export:
+                export = export.split(':')
+            else:
+                export = [export]
+            for e in export:
+                paths.append(e.replace('${prefix}', pkg_dir))
+    else:
+        dirs = [os.path.join(pkg_dir, d) for d in ['src', 'lib']]
+        paths.extend(list(filter(os.path.isdir, dirs))) #py3k
+    
+def _generate_python_path(pkg, depends, env=os.environ):
+    """
+    Recursive subroutine for building dependency list and python path
+    @param manifest_file: manifest to parse for additional dependencies
+    @param depends: current dependency set. Will be modified
+    @return: list of directory paths to add to python path in order to include
+      package and dependencies described in manifest file.
+    @raise InvalidROSPkgException: if an error occurs while attempting to load package or dependencies
+    """
+    if pkg in _bootstrapped:
+        return []
+    manifest_file = roslib_electric.manifest.manifest_file(pkg, True, env)
+    if not manifest_file:
+        raise roslib_electric.packages.InvalidROSPkgException("cannot locate package [%s]"%pkg)
+    _bootstrapped.append(pkg)
+    
+    pkg_dir = os.path.dirname(os.path.abspath(manifest_file))
+    depends.append(pkg)
+    m = roslib_electric.manifest.parse_file(manifest_file)
+    
+    paths = []
+    _append_package_paths(m, paths, pkg_dir)
+
+    try:
+        for d in m.depends:
+            if d.package in depends:
+                continue 
+            try: #add sub-dependencies to paths and depends
+                paths.extend(_generate_python_path(d.package, depends, env))
+            except roslib_electric.packages.InvalidROSPkgException as e:
+                # translate error message to give more context
+                raise roslib_electric.packages.InvalidROSPkgException("While loading package '%s': %s"%(d.package, str(e)))
+            except:
+                import traceback
+                raise roslib_electric.packages.InvalidROSPkgException("While loading package '%s': cannot load dependency '%s'\nLower level error was %s"%(pkg, d.package, traceback.format_exc()))
+    except:
+        if pkg in _bootstrapped:
+            _bootstrapped.remove(pkg)
+        raise
+    return paths
diff -r cc8bd7a5eafb roslib_electric/src/roslib_electric/manifest.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/src/roslib_electric/manifest.py	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,152 @@
+#! /usr/bin/env python
+# Software License Agreement (BSD License)
+#
+# Copyright (c) 2008, Willow Garage, Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+#  * Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#  * Redistributions in binary form must reproduce the above
+#    copyright notice, this list of conditions and the following
+#    disclaimer in the documentation and/or other materials provided
+#    with the distribution.
+#  * Neither the name of Willow Garage, Inc. nor the names of its
+#    contributors may be used to endorse or promote products derived
+#    from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+# Revision $Id: manifest.py 14291 2011-07-13 03:24:43Z kwc $
+# $Author: kwc $
+
+"""
+Python parser for rospack manifest.xml files. See U{http://ros.org/wiki/Manifest}
+"""
+
+import sys
+import os
+import getopt
+
+import roslib_electric.exceptions
+import roslib_electric.packages
+import roslib_electric.rosenv
+
+MANIFEST_FILE = 'manifest.xml'
+
+import roslib_electric.manifestlib
+# re-export symbols for backwards compatibility
+from roslib_electric.manifestlib import ManifestException, Depend, Export, ROSDep, VersionControl
+
+class Manifest(roslib_electric.manifestlib._Manifest):
+    """
+    Object representation of a ROS manifest file
+    """
+    __slots__ = []
+    def __init__(self):
+        """
+        Initialize new empty manifest.
+        """
+        super(Manifest, self).__init__('package')
+        
+    def get_export(self, tag, attr):
+        """
+        @return: exports that match the specified tag and attribute, e.g. 'python', 'path'
+        @rtype: [L{Export}]
+        """
+        return [e.get(attr) for e in self.exports if e.tag == tag if e.get(attr) is not None]
+
+def _manifest_file_by_dir(package_dir, required=True, env=None):
+    """
+    @param package_dir: path to package directory
+    @type  package_dir: str
+    @param env: environment dictionary
+    @type  env: dict
+    @param required: require that the directory exist
+    @type  required: bool
+    @return: path to manifest file of package
+    @rtype:  str
+    @raise InvalidROSPkgException: if required is True and manifest file cannot be located
+    """
+    if env is None:
+        env = os.environ
+    try:
+        p = os.path.join(package_dir, MANIFEST_FILE)
+        if not required and not os.path.exists(p):
+            return p
+        if not os.path.isfile(p):
+            raise roslib_electric.packages.InvalidROSPkgException("""
+Package '%(package_dir)s' is improperly configured: no manifest file is present.
+"""%locals())
+        return p
+    except roslib_electric.packages.InvalidROSPkgException as e:
+        if required:
+            raise
+
+def manifest_file(package, required=True, env=None):
+    """
+    @param package str: package name
+    @type  package: str
+    @param env: override os.environ dictionary
+    @type  env: dict
+    @param required: require that the directory exist
+    @type  required: bool
+    @return: path to manifest file of package
+    @rtype: str
+    @raise InvalidROSPkgException: if required is True and manifest file cannot be located
+    """
+    # ros_root needs to be determined from the environment or else
+    # everything breaks when trying to launch nodes via ssh where the
+    # path isn't setup correctly.
+    if env is None:
+        env = os.environ
+    d = roslib_electric.packages.get_pkg_dir(package, required, ros_root=env[roslib_electric.rosenv.ROS_ROOT]) 
+    return _manifest_file_by_dir(d, required=required, env=env)
+
+def load_manifest(package):
+    """
+    Load manifest for specified package.
+    @param pacakge: package name
+    @type  package: str
+    @return: Manifest instance
+    @rtype: L{Manifest}
+    @raise InvalidROSPkgException: if package is unknown
+    """
+    return parse_file(manifest_file(package))
+    
+def parse_file(file):
+    """
+    Parse manifest.xml file
+    @param file: manifest.xml file path
+    @type  file: str
+    @return: Manifest instance
+    @rtype: L{Manifest}
+    """
+    return roslib_electric.manifestlib.parse_file(Manifest(), file)
+
+def parse(string, filename='string'):
+    """
+    Parse manifest.xml string contents
+    @param string: manifest.xml contents
+    @type  string: str
+    @return: Manifest instance
+    @rtype: L{Manifest}
+    """
+    v = roslib_electric.manifestlib.parse(Manifest(), string, filename)
+    if v.version:
+        raise ManifestException("<version> tag is not valid in a package manifest.xml file")
+    return v
diff -r cc8bd7a5eafb roslib_electric/src/roslib_electric/manifestlib.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/src/roslib_electric/manifestlib.py	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,565 @@
+#! /usr/bin/env python
+# Software License Agreement (BSD License)
+#
+# Copyright (c) 2008, Willow Garage, Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+#  * Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#  * Redistributions in binary form must reproduce the above
+#    copyright notice, this list of conditions and the following
+#    disclaimer in the documentation and/or other materials provided
+#    with the distribution.
+#  * Neither the name of Willow Garage, Inc. nor the names of its
+#    contributors may be used to endorse or promote products derived
+#    from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+# Revision $Id: manifestlib.py 14595 2011-08-08 16:25:36Z kwc $
+# $Author: kwc $
+
+"""
+Internal library for processing 'manifest' files, i.e. manifest.xml and stack.xml.
+For external code apis, see L{roslib_electric.manifest} and L{roslib_electric.stack_manifest}.
+"""
+
+import sys
+import os
+import xml.dom
+import xml.dom.minidom as dom
+
+import roslib_electric.exceptions
+
+# stack.xml and manifest.xml have the same internal tags right now
+REQUIRED = ['author', 'license']
+ALLOWXHTML = ['description']
+OPTIONAL = ['logo', 'url', 'brief', 'description', 'status',
+            'notes', 'depend', 'rosdep', 'export', 'review',
+            'versioncontrol', 'platform', 'version', 'rosbuild2']
+VALID = REQUIRED + OPTIONAL
+
+class ManifestException(roslib_electric.exceptions.ROSLibException): pass
+
+def get_nodes_by_name(n, name):
+    return [t for t in n.childNodes if t.nodeType == t.ELEMENT_NODE and t.tagName == name]
+    
+def check_optional(name, allowXHTML=False):
+    """
+    Validator for optional elements.
+    @raise ManifestException: if validation fails
+    """
+    def check(n, filename):
+        n = get_nodes_by_name(n, name)
+        if len(n) > 1:
+            raise ManifestException("Invalid manifest file: must have a single '%s' element"%name)
+        if n:
+            if allowXHTML:
+                return ''.join([x.toxml() for x in n[0].childNodes])
+            return _get_text(n[0].childNodes).strip()
+    return check
+
+def check_required(name, allowXHTML=False):
+    """
+    Validator for required elements.
+    @raise ManifestException: if validation fails
+    """
+    def check(n, filename):
+        n = get_nodes_by_name(n, name)
+        if not n:
+            #print >> sys.stderr, "Invalid manifest file[%s]: missing required '%s' element"%(filename, name)
+            return ''
+        if len(n) != 1:
+            raise ManifestException("Invalid manifest file: must have only one '%s' element"%name)
+        if allowXHTML:
+            return ''.join([x.toxml() for x in n[0].childNodes])
+        return _get_text(n[0].childNodes).strip()
+    return check
+
+def check_platform(name):
+    """
+    Validator for manifest platform.
+    @raise ManifestException: if validation fails
+    """
+    def check(n, filename):
+        platforms = get_nodes_by_name(n, name)
+        try:
+            vals = [(p.attributes['os'].value, p.attributes['version'].value, p.getAttribute('notes')) for p in platforms]
+        except KeyError as e:
+            raise ManifestException("<platform> tag is missing required '%s' attribute"%str(e))
+        return [Platform(*v) for v in vals]
+    return check
+
+def check_depends(name):
+    """
+    Validator for manifest depends.
+    @raise ManifestException: if validation fails
+    """
+    def check(n, filename):
+        nodes = get_nodes_by_name(n, name)
+        # TDS 20110419:  this is a hack.
+        # rosbuild2 has a <depend thirdparty="depname"/> tag,
+        # which is confusing this subroutine with 
+        # KeyError: 'package'
+        # for now, explicitly don't consider thirdparty depends
+        depends = [e.attributes for e in nodes if 'thirdparty' not in e.attributes.keys()]
+        try:
+            packages = [d['package'].value for d in depends]
+        except KeyError:
+            raise ManifestException("Invalid manifest file: depends is missing 'package' attribute")
+
+        return [Depend(p) for p in packages]
+    return check
+
+def check_stack_depends(name):
+    """
+    Validator for stack depends.
+    @raise ManifestException: if validation fails
+    """
+    def check(n, filename):
+        nodes = get_nodes_by_name(n, name)
+        depends = [e.attributes for e in nodes]
+        packages = [d['stack'].value for d in depends]
+        return [StackDepend(p) for p in packages]
+    return check
+
+def check_rosdeps(name):
+    """
+    Validator for stack rosdeps.    
+    @raise ManifestException: if validation fails
+    """
+    def check(n, filename):
+        nodes = get_nodes_by_name(n, name)
+        rosdeps = [e.attributes for e in nodes]
+        names = [d['name'].value for d in rosdeps]
+        return [ROSDep(n) for n in names]
+    return check
+
+def _attrs(node):
+    attrs = {}
+    for k in node.attributes.keys(): 
+        attrs[k] = node.attributes.get(k).value
+    return attrs
+    
+def check_exports(name):
+    def check(n, filename):
+        ret_val = []
+        for e in get_nodes_by_name(n, name):
+            elements = [c for c in e.childNodes if c.nodeType == c.ELEMENT_NODE]
+            ret_val.extend([Export(t.tagName, _attrs(t), _get_text(t.childNodes)) for t in elements])
+        return ret_val 
+    return check
+
+def check_versioncontrol(name):
+    def check(n, filename):
+        e = get_nodes_by_name(n, name)
+        if not e:
+            return None
+        # note: 'url' isn't actually required, but as we only support type=svn it implicitly is for now
+        return VersionControl(e[0].attributes['type'].value, e[0].attributes['url'].value)
+    return check
+
+def check(name):
+    if name == 'depend':
+        return check_depends('depend')
+    elif name == 'export':
+        return check_exports('export')
+    elif name == 'versioncontrol':
+        return check_versioncontrol('versioncontrol')
+    elif name == 'rosdep':
+        return check_rosdeps('rosdep')
+    elif name == 'platform':
+        return check_platform('platform')
+    elif name in REQUIRED:
+        if name in ALLOWXHTML:
+            return check_required(name, True)
+        return check_required(name)            
+    elif name in OPTIONAL:
+        if name in ALLOWXHTML:
+            return check_optional(name, True)
+        return check_optional(name)
+    
+class Export(object):
+    """
+    Manifest 'export' tag
+    """
+    
+    def __init__(self, tag, attrs, str):
+        """
+        Create new export instance.
+        @param tag: name of the XML tag
+        @type  tag: str
+        @param attrs: dictionary of XML attributes for this export tag
+        @type  attrs: dict
+        @param str: string value contained by tag, if any
+        @type  str: str
+        """
+        self.tag = tag
+        self.attrs = attrs
+        self.str = str
+
+    def get(self, attr):
+        """
+        @return: value of attribute or None if attribute not set
+        @rtype:  str
+        """
+        return self.attrs.get(attr, None)
+    def xml(self):
+        """
+        @return: export instance represented as manifest XML
+        @rtype: str
+        """        
+        attrs = ' '.join([' %s="%s"'%(k,v) for k,v in self.attrs.items()]) #py3k
+        if self.str:
+            return '<%s%s>%s</%s>'%(self.tag, attrs, self.str, self.tag)
+        else:
+            return '<%s%s />'%(self.tag, attrs)
+        
+class Platform(object):
+    """
+    Manifest 'platform' tag
+    """
+    __slots__ = ['os', 'version', 'notes']
+
+    def __init__(self, os, version, notes=None):
+        """
+        Create new depend instance.
+        @param os: OS name. must be non-empty
+        @type  os: str
+        @param version: OS version. must be non-empty
+        @type  version: str
+        @param notes: (optional) notes about platform support
+        @type  notes: str
+        """
+        if not os:
+            raise ValueError("bad 'os' attribute")
+        if not version:
+            raise ValueError("bad 'version' attribute")
+        self.os = os
+        self.version = version
+        self.notes = notes
+        
+    def __str__(self):
+        return "%s %s"%(self.os, self.version)
+    def __repr__(self):
+        return "%s %s"%(self.os, self.version)
+    def __eq__(self, obj):
+        """
+        Override equality test. notes *are* considered in the equality test.
+        """
+        if not isinstance(obj, Platform):
+            return False
+        return self.os == obj.os and self.version == obj.version and self.notes == obj.notes 
+    def xml(self):
+        """
+        @return: instance represented as manifest XML
+        @rtype: str
+        """
+        if self.notes is not None:
+            return '<platform os="%s" version="%s" notes="%s"/>'%(self.os, self.version, self.notes)
+        else:
+            return '<platform os="%s" version="%s"/>'%(self.os, self.version)
+
+class Depend(object):
+    """
+    Manifest 'depend' tag
+    """
+    __slots__ = ['package']
+
+    def __init__(self, package):
+        """
+        Create new depend instance.
+        @param package: package name. must be non-empty
+        @type  package: str
+        """
+        if not package:
+            raise ValueError("bad 'package' attribute")
+        self.package = package
+    def __str__(self):
+        return self.package
+    def __repr__(self):
+        return self.package
+    def __eq__(self, obj):
+        if not isinstance(obj, Depend):
+            return False
+        return self.package == obj.package 
+    def xml(self):
+        """
+        @return: depend instance represented as manifest XML
+        @rtype: str
+        """
+        return '<depend package="%s" />'%self.package
+        
+class StackDepend(object):
+    """
+    Stack Manifest 'depend' tag
+    """
+    __slots__ = ['stack', 'annotation']
+
+    def __init__(self, stack):
+        """
+        @param stack: stack name. must be non-empty
+        @type  stack: str
+        """
+        if not stack:
+            raise ValueError("bad 'stack' attribute")
+        self.stack = stack
+        self.annotation = None
+        
+    def __str__(self):
+        return self.stack
+    def __repr__(self):
+        return self.stack
+    def __eq__(self, obj):
+        if not isinstance(obj, StackDepend):
+            return False
+        return self.stack == obj.stack 
+    def xml(self):
+        """
+        @return: stack depend instance represented as stack manifest XML
+        @rtype: str
+        """
+        if self.annotation:
+            return '<depend stack="%s" /> <!-- %s -->'%(self.stack, self.annotation)
+        else:
+            return '<depend stack="%s" />'%self.stack            
+
+class ROSDep(object):
+    """
+    Manifest 'rosdep' tag    
+    """
+    __slots__ = ['name',]
+
+    def __init__(self, name):
+        """
+        Create new rosdep instance.
+        @param name: dependency name. Must be non-empty.
+        @type  name: str
+        """
+        if not name:
+            raise ValueError("bad 'name' attribute")
+        self.name = name
+    def xml(self):
+        """
+        @return: rosdep instance represented as manifest XML
+        @rtype: str
+        """        
+        return '<rosdep name="%s" />'%self.name
+
+class VersionControl(object):
+    """
+    Manifest 'versioncontrol' tag
+    """
+    __slots__ = ['type', 'url']
+
+    def __init__(self, type_, url):
+        """
+        @param type_: version control type (e.g. 'svn'). must be non empty
+        @type  type_: str
+        @param url: URL associated with version control. must be non empty
+        @type  url: str
+        """
+        if not type_ or not isinstance(type_, basestring):
+            raise ValueError("bad 'type' attribute")
+        if not url is None and not isinstance(url, basestring):
+            raise ValueError("bad 'url' attribute")
+        self.type = type_
+        self.url = url
+    def xml(self):
+        """
+        @return: versioncontrol instance represented as manifest XML
+        @rtype: str
+        """        
+        if self.url:
+            return '<versioncontrol type="%s" url="%s" />'%(self.type, self.url)
+        else:
+            return '<versioncontrol type="%s" />'%self.type
+    
+class _Manifest(object):
+    """
+    Object representation of a ROS manifest file
+    """
+    __slots__ = ['description', 'brief', \
+                 'author', 'license', 'license_url', 'url', \
+                 'depends', 'rosdeps','platforms',\
+                 'logo', 'exports', 'version',\
+                 'versioncontrol', 'status', 'notes',\
+                 'unknown_tags',\
+                 '_type']
+    def __init__(self, _type='package'):
+        self.description = self.brief = self.author = \
+                           self.license = self.license_url = \
+                           self.url = self.logo = self.status = \
+                           self.version = self.notes = ''
+        self.depends = []
+        self.rosdeps = []
+        self.exports = []
+        self.platforms = []
+        self._type = _type
+        
+        # store unrecognized tags during parsing
+        self.unknown_tags = []
+        
+    def __str__(self):
+        return self.xml()
+    def get_export(self, tag, attr):
+        """
+        @return: exports that match the specified tag and attribute, e.g. 'python', 'path'
+        @rtype: [L{Export}]
+        """
+        return [e.get(attr) for e in self.exports if e.tag == tag if e.get(attr) is not None]
+    def xml(self):
+        """
+        @return: Manifest instance as ROS XML manifest
+        @rtype: str
+        """
+        if not self.brief:
+            desc = "  <description>%s</description>"%self.description
+        else:
+            desc = '  <description brief="%s">%s</description>'%(self.brief, self.description) 
+        author  = "  <author>%s</author>"%self.author
+        if self.license_url:
+            license = '  <license url="%s">%s</license>'%(self.license_url, self.license)
+        else:
+            license = "  <license>%s</license>"%self.license
+        versioncontrol = url = logo = exports = version = ""
+        if self.url:
+            url     = "  <url>%s</url>"%self.url
+        if self.version:
+            version = "  <version>%s</version>"%self.version
+        if self.logo:
+            logo    = "  <logo>%s</logo>"%self.logo
+        depends = '\n'.join(["  %s"%d.xml() for d in self.depends])
+        rosdeps = '\n'.join(["  %s"%rd.xml() for rd in self.rosdeps])
+        platforms = '\n'.join(["  %s"%p.xml() for p in self.platforms])
+        if self.exports:
+            exports = '  <export>\n' + '\n'.join(["  %s"%e.xml() for e in self.exports]) + '  </export>'
+        if self.versioncontrol:
+            versioncontrol = "  %s"%self.versioncontrol.xml()
+        if self.status or self.notes:
+            review = '  <review status="%s" notes="%s" />'%(self.status, self.notes)
+
+
+        fields = filter(lambda x: x,
+                        [desc, author, license, review, url, logo, depends,
+                         rosdeps, platforms, exports, versioncontrol, version])
+        return "<%s>\n"%self._type + "\n".join(fields) + "\n</%s>"%self._type
+
+def _get_text(nodes):
+    """
+    DOM utility routine for getting contents of text nodes
+    """
+    return "".join([n.data for n in nodes if n.nodeType == n.TEXT_NODE])
+
+def parse_file(m, file):
+    """
+    Parse manifest file (package, stack)
+    @param m: field to populate
+    @type  m: L{_Manifest}
+    @param file: manifest.xml file path
+    @type  file: str
+    @return: return m, populated with parsed fields
+    @rtype: L{_Manifest}
+    """
+    if not file:
+        raise ValueError("Missing manifest file argument")
+    if not os.path.isfile(file):
+        raise ValueError("Invalid/non-existent manifest file: %s"%file)
+    with open(file, 'r') as f:
+        text = f.read()
+    try:
+        return parse(m, text, file)
+    except ManifestException as e:
+        raise ManifestException("Invalid manifest file [%s]: %s"%(os.path.abspath(file), e))
+
+def parse(m, string, filename='string'):
+    """
+    Parse manifest.xml string contents
+    @param string: manifest.xml contents
+    @type  string: str
+    @param m: field to populate
+    @type  m: L{_Manifest}
+    @return: return m, populated with parsed fields
+    @rtype: L{_Manifest}
+    """
+    try:
+        d = dom.parseString(string)
+    except Exception as e:
+        raise ManifestException("invalid XML: %s"%e)
+    
+    p = get_nodes_by_name(d, m._type)
+    if len(p) != 1:
+        raise ManifestException("manifest must have a single '%s' element"%m._type)
+    p = p[0]
+    m.description = check('description')(p, filename)
+    m.brief = ''
+    try:
+        tag = get_nodes_by_name(p, 'description')[0]
+        m.brief = tag.getAttribute('brief') or ''
+    except:
+        # means that 'description' tag is missing
+        pass
+    #TODO: figure out how to multiplex
+    if m._type == 'package':
+        m.depends = check_depends('depend')(p, filename)
+    elif m._type == 'stack':
+        m.depends = check_stack_depends('depend')(p, filename)
+    elif m._type == 'app':
+        # not implemented yet
+        pass
+    m.rosdeps = check('rosdep')(p, filename)    
+    m.platforms = check('platform')(p, filename)    
+    m.exports = check('export')(p, filename)
+    m.versioncontrol = check('versioncontrol')(p,filename)
+    m.license = check('license')(p, filename)
+    m.license_url = ''
+    try:
+        tag = get_nodes_by_name(p, 'license')[0]
+        m.license_url = tag.getAttribute('url') or ''
+    except:
+        pass #manifest is missing required 'license' tag
+  
+    m.status='unreviewed'
+    try:
+        tag = get_nodes_by_name(p, 'review')[0]
+        m.status=tag.getAttribute('status') or ''
+    except:
+        pass #manifest is missing optional 'review status' tag
+
+    m.notes=''
+    try:
+        tag = get_nodes_by_name(p, 'review')[0]
+        m.notes=tag.getAttribute('notes') or ''
+    except:
+        pass #manifest is missing optional 'review notes' tag
+
+    m.author = check('author')(p, filename)
+    m.url = check('url')(p, filename)
+    m.version = check('version')(p, filename)
+    m.logo = check('logo')(p, filename)
+
+    # do some validation on what we just parsed
+    if m._type == 'stack':
+        if m.exports:
+            raise ManifestException("stack manifests are not allowed to have exports")
+        if m.rosdeps:
+            raise ManifestException("stack manifests are not allowed to have rosdeps") 
+
+    # store unrecognized tags
+    m.unknown_tags = [e for e in p.childNodes if e.nodeType == e.ELEMENT_NODE and e.tagName not in VALID]
+    return m
diff -r cc8bd7a5eafb roslib_electric/src/roslib_electric/message.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/src/roslib_electric/message.py	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,637 @@
+# Software License Agreement (BSD License)
+#
+# Copyright (c) 2008, Willow Garage, Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+#  * Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#  * Redistributions in binary form must reproduce the above
+#    copyright notice, this list of conditions and the following
+#    disclaimer in the documentation and/or other materials provided
+#    with the distribution.
+#  * Neither the name of Willow Garage, Inc. nor the names of its
+#    contributors may be used to endorse or promote products derived
+#    from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+# Revision $Id: message.py 15915 2012-01-11 23:18:09Z kwc $
+
+"""
+Support library for Python autogenerated message files. This defines
+the L{Message} base class used by genmsg_py as well as support
+libraries for type checking and retrieving message classes by type
+name.
+"""
+
+import math
+import itertools
+import traceback
+import struct
+import sys
+
+import roslib_electric.exceptions
+from roslib_electric.rostime import Time, Duration, TVal
+
+# common struct pattern singletons for msgs to use. Although this
+# would better placed in a generator-specific module, we don't want to
+# add another import to messages (which incurs higher import cost)
+
+if sys.version > '3':
+	long = int
+
+struct_I = struct.Struct('<I')
+
+def isstring(s):
+    """Small helper version to check an object is a string in a way that works
+    for both Python 2 and 3
+    """
+    try:
+        return isinstance(s, basestring)
+    except NameError:
+        return isinstance(s, str)
+    
+class ROSMessageException(roslib_electric.exceptions.ROSLibException):
+    """
+    Exception type for errors in roslib_electric.message routines
+    """
+    pass
+
+def _get_message_or_service_class(type_str, message_type, reload_on_error=False):
+    """
+    Utility for retrieving message/service class instances. Used by
+    get_message_class and get_service_class. 
+    @param type_str: 'msg' or 'srv'
+    @type  type_str: str
+    @param message_type: type name of message/service
+    @type  message_type: str
+    @return: Message/Service  for message/service type or None
+    @rtype: class
+    @raise ValueError: if message_type is invalidly specified
+    """
+    ## parse package and local type name for import
+    package, base_type = roslib_electric.names.package_resource_name(message_type)
+    if not package:
+        if base_type == roslib_electric.msgs.HEADER:
+            package = 'std_msgs'
+        else:
+            raise ValueError("message type is missing package name: %s"%str(message_type))
+    pypkg = val = None
+    try: 
+        # bootstrap our sys.path
+        roslib_electric.launcher.load_manifest(package)
+        # import the package and return the class
+        pypkg = __import__('%s.%s'%(package, type_str))
+        val = getattr(getattr(pypkg, type_str), base_type)
+    except roslib_electric.packages.InvalidROSPkgException:
+        val = None
+    except ImportError:
+        val = None
+    except AttributeError:
+        val = None
+
+    # this logic is mainly to support rosh, so that a user doesn't
+    # have to exit a shell just because a message wasn't built yet
+    if val is None and reload_on_error:
+        try:
+            if pypkg:
+                reload(pypkg)
+            val = getattr(getattr(pypkg, type_str), base_type)
+        except:
+            val = None
+    return val
+        
+## cache for get_message_class
+_message_class_cache = {}
+
+def get_message_class(message_type, reload_on_error=False):
+    """
+    Get the message class. NOTE: this function maintains a
+    local cache of results to improve performance.
+    @param message_type: type name of message
+    @type  message_type: str
+    @param reload_on_error: (optional). Attempt to reload the Python
+      module if unable to load message the first time. Defaults to
+      False. This is necessary if messages are built after the first load.
+    @return: Message class for message/service type
+    @rtype:  Message class
+    @raise ValueError: if  message_type is invalidly specified
+    """
+    if message_type in _message_class_cache:
+        return _message_class_cache[message_type]
+    cls = _get_message_or_service_class('msg', message_type, reload_on_error=reload_on_error)
+    if cls:
+        _message_class_cache[message_type] = cls
+    return cls
+
+## cache for get_service_class
+_service_class_cache = {}
+
+def get_service_class(service_type, reload_on_error=False):
+    """
+    Get the service class. NOTE: this function maintains a
+    local cache of results to improve performance.
+    @param service_type: type name of service
+    @type  service_type: str
+    @param reload_on_error: (optional). Attempt to reload the Python
+      module if unable to load message the first time. Defaults to
+      False. This is necessary if messages are built after the first load.
+    @return: Service class for service type
+    @rtype: Service class
+    @raise Exception: if service_type is invalidly specified
+    """
+    if service_type in _service_class_cache:
+        return _service_class_cache[service_type]
+    cls = _get_message_or_service_class('srv', service_type, reload_on_error=reload_on_error)
+    _service_class_cache[service_type] = cls
+    return cls
+
+# we expose the generic message-strify routine for fn-oriented code like rostopic
+
+def strify_message(val, indent='', time_offset=None, current_time=None, field_filter=None):
+    """
+    Convert value to string representation
+    @param val: to convert to string representation. Most likely a Message.
+    @type  val: Value
+    @param indent: indentation. If indent is set, then the return value will have a leading \n
+    @type  indent: str
+    @param time_offset: if not None, time fields will be displayed
+    as deltas from  time_offset
+    @type  time_offset: Time
+    @param current_time: currently not used. Only provided for API compatibility. current_time passes in the current time with respect to the message.
+    @type  current_time: Time
+    @param field_filter: filter the fields that are strified for Messages.
+    @type  field_filter: fn(Message)->iter(str)
+    @return: string (YAML) representation of message
+    @rtype: str
+    """
+
+    type_ = type(val)
+    if type_ in (int, long, float, bool):
+        return str(val)
+    elif isstring(val):
+        #TODO: need to escape strings correctly
+        if not val:
+            return "''"
+        return val
+    elif isinstance(val, TVal):
+        
+        if time_offset is not None and isinstance(val, Time):
+            val = val-time_offset
+
+        return '\n%ssecs: %s\n%snsecs: %s'%(indent, val.secs, indent, val.nsecs)
+        
+    elif type_ in (list, tuple):
+        if len(val) == 0:
+            return "[]"
+        val0 = val[0]
+        if type(val0) in (int, float, str, bool):
+            # TODO: escape strings properly
+            return str(list(val))
+        else:
+            pref = indent + '- '
+            indent = indent + '  '
+            return '\n'+'\n'.join([pref+strify_message(v, indent, time_offset, current_time, field_filter) for v in val])
+    elif isinstance(val, Message):
+        # allow caller to select which fields of message are strified
+        if field_filter is not None:
+            fields = list(field_filter(val))
+        else:
+            fields = val.__slots__
+
+        p = '%s%%s: %%s'%(indent)
+        ni = '  '+indent
+        if sys.hexversion > 0x03000000: #Python3
+            vals = '\n'.join([p%(f,
+                                 strify_message(_convert_getattr(val, f, t), ni, time_offset, current_time, field_filter)) for f,t in zip(val.__slots__, val._slot_types) if f in fields])			
+        else: #Python2
+            vals = '\n'.join([p%(f,
+                                 strify_message(_convert_getattr(val, f, t), ni, time_offset, current_time, field_filter)) for f,t in itertools.izip(val.__slots__, val._slot_types) if f in fields])
+        if indent:
+            return '\n'+vals
+        else:
+            return vals
+        
+    else:
+        return str(val) #punt
+
+def _convert_getattr(val, f, t):
+    """
+    Convert atttribute types on the fly, if necessary.  This is mainly
+    to convert uint8[] fields back to an array type.
+    """
+    attr = getattr(val, f)
+    if isstring(attr) and 'uint8[' in t:
+        return [ord(x) for x in attr]
+    else:
+        return attr
+
+# check_type mildly violates some abstraction boundaries between .msg
+# representation and the python Message representation. The
+# alternative is to have the message generator map .msg types to
+# python types beforehand, but that would make it harder to do
+# width/signed checks.
+
+_widths = {
+    'byte': 8, 'char': 8, 'int8': 8, 'uint8': 8,
+    'int16': 16, 'uint16': 16, 
+    'int32': 32, 'uint32': 32, 
+    'int64': 64, 'uint64': 64, 
+}
+
+def check_type(field_name, field_type, field_val):
+    """
+    Dynamic type checker that maps ROS .msg types to python types and
+    verifies the python value.  check_type() is not designed to be
+    fast and is targeted at error diagnosis. This type checker is not
+    designed to run fast and is meant only for error diagnosis.
+    
+    @param field_name: ROS .msg field name
+    @type  field_name: str
+    @param field_type: ROS .msg field type
+    @type  field_type: str
+    @param field_val: field value
+    @type  field_val: Any
+    @raise SerializationError: if typecheck fails
+    """
+    # lazy-import as roslib_electric.genpy has lots of extra imports. Would
+    # prefer to do lazy-init in a different manner
+    import roslib_electric.genpy
+    if roslib_electric.genpy.is_simple(field_type):
+        # check sign and width
+        if field_type in ['byte', 'int8', 'int16', 'int32', 'int64']:
+            if type(field_val) not in [long, int]:
+                raise SerializationError('field %s must be an integer type'%field_name)
+            maxval = int(math.pow(2, _widths[field_type]-1))
+            if field_val >= maxval or field_val <= -maxval:
+                raise SerializationError('field %s exceeds specified width [%s]'%(field_name, field_type))
+        elif field_type in ['char', 'uint8', 'uint16', 'uint32', 'uint64']:
+            if type(field_val) not in [long, int] or field_val < 0:
+                raise SerializationError('field %s must be unsigned integer type'%field_name)
+            maxval = int(math.pow(2, _widths[field_type]))
+            if field_val >= maxval:
+                raise SerializationError('field %s exceeds specified width [%s]'%(field_name, field_type))
+        elif field_type == 'bool':
+            if field_val not in [True, False, 0, 1]:
+                raise SerializationError('field %s is not a bool'%(field_name))
+    elif field_type == 'string':
+        if sys.hexversion > 0x03000000:
+            if type(field_val) == str:
+                raise SerializationError('field %s is a unicode string instead of an ascii string'%field_name)	
+        else:		
+            if type(field_val) == unicode:
+                raise SerializationError('field %s is a unicode string instead of an ascii string'%field_name)
+            elif not isstring(field_val):
+                raise SerializationError('field %s must be of type str'%field_name)
+    elif field_type == 'time':
+        if not isinstance(field_val, Time):
+            raise SerializationError('field %s must be of type Time'%field_name)
+    elif field_type == 'duration':
+        if not isinstance(field_val, Duration):
+            raise SerializationError('field %s must be of type Duration'%field_name)
+        
+    elif field_type.endswith(']'): # array type
+        # use index to generate error if '[' not present
+        base_type = field_type[:field_type.index('[')]
+
+        if type(field_val) == str:
+            if not base_type in ['char', 'uint8']:
+                raise SerializationError('field %s must be a list or tuple type. Only uint8[] can be a string' % field_name);
+            else:
+                #It's a string so its already in byte format and we
+                #don't need to check the individual bytes in the
+                #string.
+                return
+            
+        if not type(field_val) in [list, tuple]:
+            raise SerializationError('field %s must be a list or tuple type'%field_name)
+        for v in field_val:
+            check_type(field_name+"[]", base_type, v)
+    else:
+        if isinstance(field_val, Message):
+            # roslib/Header is the old location of Header. We check it for backwards compat
+            if field_val._type in ['std_msgs/Header', 'roslib/Header']:
+                if field_type not in ['Header', 'std_msgs/Header', 'roslib/Header']:
+                    raise SerializationError("field %s must be a Header instead of a %s"%(field_name, field_val._type))
+            elif field_val._type != field_type:
+                raise SerializationError("field %s must be of type %s instead of %s"%(field_name, field_type, field_val._type))
+            for n, t in zip(field_val.__slots__, field_val._get_types()):
+                check_type("%s.%s"%(field_name,n), t, getattr(field_val, n))
+        else:
+            raise SerializationError("field %s must be of type [%s]"%(field_name, field_type))
+
+        #TODO: dynamically load message class and do instance compare
+
+class Message(object):
+    """Base class of Message data classes auto-generated from msg files. """
+
+    # slots is explicitly both for data representation and
+    # performance. Higher-level code assumes that there is a 1-to-1
+    # mapping between __slots__ and message fields. In terms of
+    # performance, explicitly settings slots eliminates dictionary for
+    # new-style object.
+    __slots__ = ['_connection_header']
+    
+    def __init__(self, *args, **kwds):
+        """
+        Create a new Message instance. There are multiple ways of
+        initializing Message instances, either using a 1-to-1
+        correspondence between constructor arguments and message
+        fields (*args), or using Python "keyword" arguments (**kwds) to initialize named field
+        and leave the rest with default values.
+        """
+        if args and kwds:
+            raise TypeError("Message constructor may only use args OR keywords, not both")
+        if args:
+            if len(args) != len(self.__slots__):
+                raise TypeError("Invalid number of arguments, args should be %s"%str(self.__slots__)+" args are"+str(args))
+            for i, k in enumerate(self.__slots__):
+                setattr(self, k, args[i])
+        else:
+            # validate kwds
+            for k,v in kwds.items():
+                if not k in self.__slots__:
+                    raise AttributeError("%s is not an attribute of %s"%(k, self.__class__.__name__))
+            # iterate through slots so all fields are initialized.
+            # this is important so that subclasses don't reference an
+            # uninitialized field and raise an AttributeError.
+            for k in self.__slots__:
+                if k in kwds:
+                    setattr(self, k, kwds[k])
+                else:
+                    setattr(self, k, None)
+
+    def __getstate__(self):
+        """
+        support for Python pickling
+        """
+        return [getattr(self, x) for x in self.__slots__]
+
+    def __setstate__(self, state):
+        """
+        support for Python pickling
+        """
+        for x, val in zip(self.__slots__, state):
+            setattr(self, x, val)
+
+    def _get_types(self):
+        raise Exception("must be overriden")
+    def _check_types(self, exc=None):
+        """
+        Perform dynamic type-checking of Message fields. This is performance intensive
+        and is meant for post-error diagnosis
+        @param exc: underlying exception that gave cause for type check. 
+        @type  exc: Exception
+        @raise roslib_electric.messages.SerializationError: if typecheck fails
+        """
+        for n, t in zip(self.__slots__, self._get_types()):
+            check_type(n, t, getattr(self, n))
+        if exc: # if exc is set and check_type could not diagnose, raise wrapped error
+            raise SerializationError(str(exc))
+
+    def serialize(self, buff):
+        """
+        Serialize data into buffer
+        @param buff: buffer
+        @type buff: StringIO
+        """
+        pass
+    def deserialize(self, str):
+        """
+        Deserialize data in str into this instance
+        @param str: serialized data
+        @type str: str
+        """
+        pass
+    def __repr__(self):
+        return strify_message(self)
+    def __str__(self):
+        return strify_message(self)
+    # TODO: unit test
+    def __eq__(self, other):
+        if not isinstance(other, self.__class__):
+            return False
+        for f in self.__slots__:
+            try:
+                v1 = getattr(self, f) 
+                v2 = getattr(other, f)
+                if type(v1) in (list, tuple) and type(v2) in (list, tuple):
+                    # we treat tuples and lists as equivalent
+                    if tuple(v1) != tuple(v2):
+                        return False
+                elif not v1 == v2:
+                    return False
+            except AttributeError:
+                return False
+        return True
+    
+class ServiceDefinition(object):
+    """Base class of Service classes auto-generated from srv files"""
+    pass
+
+class DeserializationError(ROSMessageException):
+    """Message deserialization error"""
+    pass
+class SerializationError(ROSMessageException):
+    """Message serialization error"""
+    pass
+
+# Utilities for rostopic/rosservice
+
+def get_printable_message_args(msg, buff=None, prefix=''):
+    """
+    Get string representation of msg arguments
+    @param msg: msg message to fill
+    @type  msg: Message
+    @param prefix: field name prefix (for verbose printing)
+    @type  prefix: str
+    @return: printable representation of  msg args
+    @rtype: str
+    """
+    try:
+        from cStringIO import StringIO # Python 2.x
+        python3 = 0
+    except ImportError:
+        from io import BytesIO # Python 3.x
+        python3 = 1
+
+    if buff is None:
+        if python3 == 1:
+            buff = BytesIO()
+        else: 
+            buff = StringIO()
+    for f in msg.__slots__:
+        if isinstance(getattr(msg, f), Message):
+            get_printable_message_args(getattr(msg, f), buff=buff, prefix=(prefix+f+'.'))
+        else:
+            buff.write(prefix+f+' ')
+    return buff.getvalue().rstrip()
+
+def _fill_val(msg, f, v, keys, prefix):
+    """
+    Subroutine of L{_fill_message_args()}. Sets a particular field on a message
+    @param f: field name
+    @type  f: str
+    @param v: field value
+    @param keys: keys to use as substitute values for messages and timestamps. 
+    @type  keys: dict
+    """
+    if not f in msg.__slots__:
+        raise ROSMessageException("No field name [%s%s]"%(prefix, f))
+    def_val = getattr(msg, f)
+    if isinstance(def_val, Message) or isinstance(def_val, roslib_electric.rostime.TVal):
+        # check for substitution key, e.g. 'now'
+        if type(v) == str:
+            if v in keys:
+                setattr(msg, f, keys[v])
+            else:
+                raise ROSMessageException("No key named [%s]"%(v))
+        elif isinstance(def_val, roslib_electric.rostime.TVal) and type(v) in (int, long):
+            #special case to handle time value represented as a single number
+            #TODO: this is a lossy conversion
+            if isinstance(def_val, roslib_electric.rostime.Time):
+                setattr(msg, f, roslib_electric.rostime.Time.from_sec(v/1e9))
+            elif isinstance(def_val, roslib_electric.rostime.Duration):                    
+                setattr(msg, f, roslib_electric.rostime.Duration.from_sec(v/1e9))
+            else:
+                raise ROSMessageException("Cannot create time values of type [%s]"%(type(def_val)))
+        else:
+            _fill_message_args(def_val, v, keys, prefix=(prefix+f+'.'))
+    elif type(def_val) == list:
+        if not type(v) in [list, tuple]:
+            raise ROSMessageException("Field [%s%s] must be a list or tuple instead of: %s"%(prefix, f, type(v).__name__))
+        # determine base_type of field by looking at _slot_types
+        idx = msg.__slots__.index(f)
+        t = msg._slot_types[idx]
+        base_type, is_array, length = roslib_electric.msgs.parse_type(t)
+        # - for primitives, we just directly set (we don't
+        #   type-check. we rely on serialization type checker)
+        if base_type in roslib_electric.msgs.PRIMITIVE_TYPES:
+            # 3785
+            if length is not None and len(v) != length:
+                raise ROSMessageException("Field [%s%s] has incorrect number of elements: %s != %s"%(prefix, f, len(v), length))                
+            setattr(msg, f, v)
+
+        # - for complex types, we have to iteratively append to def_val
+        else:
+            # 3785            
+            if length is not None and len(v) != length:
+                raise ROSMessageException("Field [%s%s] has incorrect number of elements: %s != %s"%(prefix, f, len(v), length))
+            list_msg_class = get_message_class(base_type)
+            if list_msg_class is None:
+                raise ROSMessageException("Cannot instantiate messages for field [%s%s] : cannot load class %s"%(prefix, f, base_type))                
+            del def_val[:]
+            for el in v:
+                inner_msg = list_msg_class()
+                _fill_message_args(inner_msg, el, prefix)
+                def_val.append(inner_msg)
+    else:
+        #print "SET2", f, v
+        setattr(msg, f, v)
+    
+    
+def _fill_message_args(msg, msg_args, keys, prefix=''):
+    """
+    Populate message with specified args.
+    
+    @param msg: message to fill
+    @type  msg: Message
+    @param msg_args: list of arguments to set fields to
+    @type  msg_args: [args]
+    @param keys: keys to use as substitute values for messages and timestamps. 
+    @type  keys: dict
+    @param prefix: field name prefix (for verbose printing)
+    @type  prefix: str
+    @return: unused/leftover message arguments. 
+    @rtype: [args]
+    @raise ROSMessageException: if not enough message arguments to fill message
+    @raise ValueError: if msg or msg_args is not of correct type
+    """
+    if not isinstance(msg, (Message, roslib_electric.rostime.TVal)):
+        raise ValueError("msg must be a Message instance: %s"%msg)
+
+    if type(msg_args) == dict:
+        
+        #print "DICT ARGS", msg_args
+        #print "ACTIVE SLOTS",msg.__slots__
+        
+        for f, v in msg_args.items():
+            # assume that an empty key is actually an empty string
+            if v == None:
+                v = ''
+            _fill_val(msg, f, v, keys, prefix)
+    elif type(msg_args) == list:
+        
+        #print "LIST ARGS", msg_args
+        #print "ACTIVE SLOTS",msg.__slots__
+        
+        if len(msg_args) > len(msg.__slots__):
+            raise ROSMessageException("Too many arguments:\n * Given: %s\n * Expected: %s"%(msg_args, msg.__slots__))
+        elif len(msg_args) < len(msg.__slots__):
+            raise ROSMessageException("Not enough arguments:\n * Given: %s\n * Expected: %s"%(msg_args, msg.__slots__))
+        
+        for f, v in zip(msg.__slots__, msg_args):
+            _fill_val(msg, f, v, keys, prefix)
+    else:
+        raise ValueError("invalid msg_args type: %s"%str(msg_args))
+
+def fill_message_args(msg, msg_args, keys={}):
+    """
+    Populate message with specified args. Args are assumed to be a
+    list of arguments from a command-line YAML parser. See
+    http://www.ros.org/wiki/ROS/YAMLCommandLine for specification on
+    how messages are filled.
+
+    fill_message_args also takes in an optional 'keys' dictionary
+    which contain substitute values for message and time types. These
+    values must be of the correct instance type, i.e. a Message, Time,
+    or Duration. In a string key is encountered with these types, the
+    value from the keys dictionary will be used instead. This is
+    mainly used to provide values for the 'now' timestamp.
+
+    @param msg: message to fill
+    @type  msg: Message
+
+    @param msg_args: list of arguments to set fields to, or 
+      If None, msg_args will be made an empty list.
+    @type  msg_args: [args]
+
+    @param keys: keys to use as substitute values for messages and timestamps. 
+    @type  keys: dict
+    @raise ROSMessageException: if not enough/too many message arguments to fill message
+    """
+    # a list of arguments is similar to python's
+    # *args, whereas dictionaries are like **kwds. 
+
+    # empty messages serialize as a None, which we make equivalent to
+    # an empty message
+    if msg_args is None:
+        msg_args = []
+    
+    # msg_args is always a list, due to the fact it is parsed from a
+    # command-line argument list.  We have to special-case handle a
+    # list with a single dictionary, which has precedence over the
+    # general list representation. We offer this precedence as there
+    # is no other way to do kwd assignments into the outer message.
+    if len(msg_args) == 1 and type(msg_args[0]) == dict:
+        # according to spec, if we only get one msg_arg and it's a dictionary, we
+        # use it directly
+        _fill_message_args(msg, msg_args[0], keys, '')
+    else:
+        _fill_message_args(msg, msg_args, keys, '')
+
diff -r cc8bd7a5eafb roslib_electric/src/roslib_electric/msgs.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/src/roslib_electric/msgs.py	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,765 @@
+# Software License Agreement (BSD License)
+#
+# Copyright (c) 2008, Willow Garage, Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+#  * Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#  * Redistributions in binary form must reproduce the above
+#    copyright notice, this list of conditions and the following
+#    disclaimer in the documentation and/or other materials provided
+#    with the distribution.
+#  * Neither the name of Willow Garage, Inc. nor the names of its
+#    contributors may be used to endorse or promote products derived
+#    from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+# Revision $Id: msgs.py 14304 2011-07-13 08:00:40Z kwc $
+# $Author: kwc $
+
+from __future__ import print_function
+
+"""
+ROS msg library for Python
+
+Implements: U{http://ros.org/wiki/msg}
+"""
+
+try:
+    from cStringIO import StringIO # Python 2.x
+except ImportError:
+    from io import StringIO # Python 3.x
+
+import os
+import itertools
+import sys
+import re
+import string
+
+import roslib_electric.exceptions
+import roslib_electric.manifest
+import roslib_electric.packages
+import roslib_electric.names
+import roslib_electric.resources
+import roslib_electric.rospack
+
+VERBOSE = False
+
+## @return: True if msg-related scripts should print verbose output
+def is_verbose():
+    return VERBOSE
+
+## set whether msg-related scripts should print verbose output
+def set_verbose(v):
+    global VERBOSE
+    VERBOSE = v
+
+EXT = roslib_electric.names.MSG_EXT #alias
+SEP = roslib_electric.names.PRN_SEPARATOR #e.g. std_msgs/String
+## character that designates a constant assignment rather than a field
+CONSTCHAR   = '='
+COMMENTCHAR = '#'
+
+class MsgSpecException(roslib_electric.exceptions.ROSLibException): pass
+
+#TODOXXX: unit test
+def base_msg_type(type_):
+    """
+    Compute the base data type, e.g. for arrays, get the underlying array item type
+    @param type_: ROS msg type (e.g. 'std_msgs/String')
+    @type  type_: str
+    @return: base type
+    @rtype: str
+    """
+    if type_ is None:
+        return None
+    if '[' in type_:
+        return type_[:type_.find('[')]
+    return type_
+
+def resolve_type(type_, package_context):
+    """
+    Resolve type name based on current package context.
+
+    NOTE: in ROS Diamondback, 'Header' resolves to
+    'std_msgs/Header'. In previous releases, it resolves to
+    'roslib/Header' (REP 100).
+
+    e.g.::
+      resolve_type('String', 'std_msgs') -> 'std_msgs/String'
+      resolve_type('String[]', 'std_msgs') -> 'std_msgs/String[]'
+      resolve_type('std_msgs/String', 'foo') -> 'std_msgs/String'    
+      resolve_type('uint16', 'std_msgs') -> 'uint16'
+      resolve_type('uint16[]', 'std_msgs') -> 'uint16[]'
+    """
+    bt = base_msg_type(type_)
+    if bt in BUILTIN_TYPES:
+        return type_
+    elif bt == 'Header':
+        return 'std_msgs/Header'
+    elif SEP in type_:
+        return type_
+    else:
+        return "%s%s%s"%(package_context, SEP, type_)    
+
+#NOTE: this assumes that we aren't going to support multi-dimensional
+
+def parse_type(type_):
+    """
+    Parse ROS message field type
+    @param type_: ROS field type
+    @type  type_: str
+    @return: base_type, is_array, array_length
+    @rtype: str, bool, int
+    @raise MsgSpecException: if type_ cannot be parsed
+    """
+    if not type_:
+        raise MsgSpecException("Invalid empty type")
+    if '[' in type_:
+        var_length = type_.endswith('[]')
+        splits = type_.split('[')
+        if len(splits) > 2:
+            raise MsgSpecException("Currently only support 1-dimensional array types: %s"%type_)
+        if var_length:
+            return type_[:-2], True, None
+        else:
+            try:
+                length = int(splits[1][:-1])
+                return splits[0], True, length
+            except ValueError:
+                raise MsgSpecException("Invalid array dimension: [%s]"%splits[1][:-1])
+    else:
+        return type_, False, None
+   
+################################################################################
+# name validation 
+
+def is_valid_msg_type(x):
+    """
+    @return: True if the name is a syntatically legal message type name
+    @rtype: bool
+    """
+    if not x or len(x) != len(x.strip()):
+        return False
+    base = base_msg_type(x)
+    if not roslib_electric.names.is_legal_resource_name(base):
+        return False
+    #parse array indicies
+    x = x[len(base):]
+    state = 0
+    i = 0
+    for c in x:
+        if state == 0:
+            if c != '[':
+                return False
+            state = 1 #open
+        elif state == 1:
+            if c == ']':
+                state = 0 #closed
+            else:
+                try:
+                    string.atoi(c)
+                except:
+                    return False
+    return state == 0
+
+def is_valid_constant_type(x):
+    """
+    @return: True if the name is a legal constant type. Only simple types are allowed.
+    @rtype: bool
+    """
+    return x in PRIMITIVE_TYPES
+
+def is_valid_msg_field_name(x):
+    """
+    @return: True if the name is a syntatically legal message field name
+    @rtype: bool
+    """
+    return roslib_electric.names.is_legal_resource_base_name(x)
+
+# msg spec representation ##########################################
+
+class Constant(object):
+    """
+    Container class for holding a Constant declaration
+    """
+    __slots__ = ['type', 'name', 'val', 'val_text']
+    
+    def __init__(self, type_, name, val, val_text):
+        """
+        @param type_: constant type
+        @type  type_: str 
+        @param name: constant name
+        @type  name: str
+        @param val: constant value
+        @type  val: str
+        @param val_text: Original text definition of \a val
+        @type  val_text: str
+        """
+        if type is None or name is None or val is None or val_text is None:
+            raise ValueError('Constant must have non-None parameters')
+        self.type = type_
+        self.name = name.strip() #names are always stripped of whitespace
+        self.val = val
+        self.val_text = val_text
+
+    def __eq__(self, other):
+        if not isinstance(other, Constant):
+            return False
+        return self.type == other.type and self.name == other.name and self.val == other.val
+
+    def __repr__(self):
+        return "%s %s=%s"%(self.type, self.name, self.val)
+
+    def __str__(self):
+        return "%s %s=%s"%(self.type, self.name, self.val)
+
+def _strify_spec(spec, buff=None, indent=''):
+    """
+    Convert spec into a string representation. Helper routine for MsgSpec.
+    @param indent: internal use only
+    @type  indent: str
+    @param buff: internal use only
+    @type  buff: StringIO
+    @return: string representation of spec
+    @rtype: str
+    """
+    if buff is None:
+        buff = StringIO()
+    for c in spec.constants:
+        buff.write("%s%s %s=%s\n"%(indent, c.type, c.name, c.val_text))
+    for type_, name in zip(spec.types, spec.names):
+        buff.write("%s%s %s\n"%(indent, type_, name))
+        base_type = base_msg_type(type_)
+        if not base_type in BUILTIN_TYPES:
+            subspec = get_registered(base_type)
+            _strify_spec(subspec, buff, indent + '  ')
+    return buff.getvalue()
+
+class Field(object):
+    """
+    Container class for storing information about a single field in a MsgSpec
+    
+    Contains:
+    name
+    type
+    base_type
+    is_array
+    array_len
+    is_builtin
+    is_header
+    """
+    
+    def __init__(self, name, type):
+        self.name = name
+        self.type = type
+        (self.base_type, self.is_array, self.array_len) = parse_type(type)
+        self.is_header = is_header_type(self.base_type)
+        self.is_builtin = is_builtin(self.base_type)
+
+    def __repr__(self):
+        return "[%s, %s, %s, %s, %s]"%(self.name, self.type, self.base_type, self.is_array, self.array_len)
+
+class MsgSpec(object):
+    """
+    Container class for storing loaded msg description files. Field
+    types and names are stored in separate lists with 1-to-1
+    correspondence. MsgSpec can also return an md5 of the source text.
+    """
+
+    def __init__(self, types, names, constants, text, full_name = '', short_name = '', package = ''):
+        """
+        @param types: list of field types, in order of declaration
+        @type  types: [str]
+        @param names: list of field names, in order of declaration    
+        @type  names: [str]
+        @param constants: Constant declarations
+        @type  constants: [L{Constant}]
+        @param text: text of declaration
+        @type  text: str
+        @raise MsgSpecException: if spec is invalid (e.g. fields with the same name)
+        """
+        self.types = types
+        if len(set(names)) != len(names):
+            raise MsgSpecException("Duplicate field names in message: %s"%names)
+        self.names = names
+        self.constants = constants
+        assert len(self.types) == len(self.names), "len(%s) != len(%s)"%(self.types, self.names)
+        #Header.msg support
+        if (len(self.types)):
+            self.header_present = self.types[0] == HEADER and self.names[0] == 'header'
+        else:
+            self.header_present = False
+        self.text = text
+        self.full_name = full_name
+        self.short_name = short_name
+        self.package = package
+        self._parsed_fields = [Field(name, type) for (name, type) in zip(self.names, self.types)]
+        
+    def fields(self):
+        """
+        @return: zip list of types and names (e.g. [('int32', 'x'), ('int32', 'y')]
+        @rtype: [(str,str),]
+        """
+        return list(zip(self.types, self.names)) #py3k
+    
+    def parsed_fields(self):
+        """
+        @return: list of Field classes
+        @rtype: [Field,]
+        """
+        return self._parsed_fields
+
+    def has_header(self):
+        """
+        @return: True if msg decription contains a 'Header header'
+        declaration at the beginning
+        @rtype: bool
+        """
+        return self.header_present
+    def __eq__(self, other):
+        if not other or not isinstance(other, MsgSpec):
+            return False 
+        return self.types == other.types and self.names == other.names and \
+               self.constants == other.constants and self.text == other.text
+    def __ne__(self, other):
+        if not other or not isinstance(other, MsgSpec):
+            return True
+        return not self.__eq__(other)
+
+    def __repr__(self):
+        if self.constants:
+            return "MsgSpec[%s, %s, %s]"%(repr(self.constants), repr(self.types), repr(self.names))
+        else:
+            return "MsgSpec[%s, %s]"%(repr(self.types), repr(self.names))        
+
+    def __str__(self):
+        return _strify_spec(self)
+    
+# msg spec loading utilities ##########################################
+
+def reinit():
+    """
+    Reinitialize roslib_electric.msgs. This API is for message generators
+    (e.g. genpy) that need to re-initialize the registration table.
+    """
+    global _initialized , _loaded_packages
+    # unset the initialized state and unregister everything 
+    _initialized = False
+    del _loaded_packages[:]
+    REGISTERED_TYPES.clear()
+    _init()
+    
+_initialized = False
+def _init():
+    #lazy-init
+    global _initialized
+    if _initialized:
+        return
+
+    fname = '%s%s'%(HEADER, EXT)
+    std_msgs_dir = roslib_electric.packages.get_pkg_dir('std_msgs')
+    if std_msgs_dir is None:
+        raise MsgSpecException("Unable to locate roslib: %s files cannot be loaded"%EXT)
+    
+    header = os.path.join(std_msgs_dir, roslib_electric.packages.MSG_DIR, fname)
+    if not os.path.isfile(header):
+        sys.stderr.write("ERROR: cannot locate %s. Expected to find it at '%s'\n"%(fname, header))
+        return False
+
+    # register Header under both contexted and de-contexted name
+    _, spec = load_from_file(header, '')
+    register(HEADER, spec)
+    register('std_msgs/'+HEADER, spec)    
+    # backwards compat, REP 100
+    register('roslib/'+HEADER, spec)    
+    for k, spec in EXTENDED_BUILTINS.items():
+        register(k, spec)
+        
+    _initialized = True
+
+# .msg file routines ##############################################################       
+
+def _msg_filter(f):
+    """
+    Predicate for filtering directory list. matches message files
+    @param f: filename
+    @type  f: str
+    """
+    return os.path.isfile(f) and f.endswith(EXT)
+
+# also used by doxymaker
+def list_msg_types(package, include_depends):
+    """
+    List all messages in the specified package
+    @param package str: name of package to search
+    @param include_depends bool: if True, will also list messages in package dependencies
+    @return [str]: message type names
+    """
+    types = roslib_electric.resources.list_package_resources(package, include_depends, roslib_electric.packages.MSG_DIR, _msg_filter)
+    return [x[:-len(EXT)] for x in types]
+
+def msg_file(package, type_):
+    """
+    Determine the file system path for the specified .msg
+    resource. .msg resource does not have to exist.
+    
+    @param package: name of package .msg file is in
+    @type  package: str
+    @param type_: type name of message, e.g. 'Point2DFloat32'
+    @type  type_: str
+    @return: file path of .msg file in specified package
+    @rtype: str
+    """
+    return roslib_electric.packages.resource_file(package, roslib_electric.packages.MSG_DIR, type_+EXT)
+
+def get_pkg_msg_specs(package):
+    """
+    List all messages that a package contains.
+    
+    @param package: package to load messages from
+    @type  package: str
+    @return: list of message type names and specs for package, as well as a list
+        of message names that could not be processed. 
+    @rtype: [(str, L{MsgSpec}), [str]]
+    """
+    _init()
+    types = list_msg_types(package, False)
+    specs = [] #no fancy list comprehension as we want to show errors
+    failures = []
+    for t in types:
+        try: 
+            typespec = load_from_file(msg_file(package, t), package)
+            specs.append(typespec)
+        except Exception as e:
+            failures.append(t)
+            print("ERROR: unable to load %s"%t)
+    return specs, failures
+
+def load_package_dependencies(package, load_recursive=False):
+    """
+    Register all messages that the specified package depends on.
+    
+    @param load_recursive: (optional) if True, load all dependencies,
+        not just direct dependencies. By default, this is false to
+        prevent packages from incorrectly inheriting dependencies.
+    @type  load_recursive: bool
+    """
+    global _loaded_packages
+    _init()    
+    if VERBOSE:
+        print("Load dependencies for package", package)
+        
+    if not load_recursive:
+        manifest_file = roslib_electric.manifest.manifest_file(package, True)
+        m = roslib_electric.manifest.parse_file(manifest_file)
+        depends = [d.package for d in m.depends] # #391
+    else:
+        depends = roslib_electric.rospack.rospack_depends(package)
+
+    msgs = []
+    failures = []
+    for d in depends:
+        if VERBOSE:
+            print("Load dependency", d)
+        #check if already loaded
+        # - we are dependent on manifest.getAll returning first-order dependencies first
+        if d in _loaded_packages or d == package:
+            continue
+        _loaded_packages.append(d)
+        specs, failed = get_pkg_msg_specs(d)
+        msgs.extend(specs)
+        failures.extend(failed)
+    for key, spec in msgs:
+        register(key, spec)
+
+def load_package(package):
+    """
+    Load package into the local registered namespace. All messages found
+    in the package will be registered if they are successfully
+    loaded. This should only be done with one package (i.e. the 'main'
+    package) per Python instance.
+
+    @param package: package name
+    @type  package: str
+    """
+    global _loaded_packages
+    _init()    
+    if VERBOSE:
+        print("Load package", package)
+        
+    #check if already loaded
+    # - we are dependent on manifest.getAll returning first-order dependencies first
+    if package in _loaded_packages:
+        if VERBOSE:
+            print("Package %s is already loaded"%package)
+        return
+
+    _loaded_packages.append(package)
+    specs, failed = get_pkg_msg_specs(package)
+    if VERBOSE:
+        print("Package contains the following messages: %s"%specs)
+    for key, spec in specs:
+        #register spec under both local and fully-qualified key
+        register(key, spec)
+        register(package + roslib_electric.names.PRN_SEPARATOR + key, spec)        
+
+def _convert_val(type_, val):
+    """
+    Convert constant value declaration to python value. Does not do
+    type-checking, so ValueError or other exceptions may be raised.
+    
+    @param type_: ROS field type
+    @type  type_: str
+    @param val: string representation of constant
+    @type  val: str:
+    @raise ValueError: if unable to convert to python representation
+    @raise MsgSpecException: if value exceeds specified integer width
+    """
+    if type_ in ['float32','float64']:
+        return float(val)
+    elif type_ in ['string']:
+        return val.strip() #string constants are always stripped 
+    elif type_ in ['int8', 'uint8', 'int16','uint16','int32','uint32','int64','uint64', 'char', 'byte']:
+        # bounds checking
+        bits = [('int8', 8), ('uint8', 8), ('int16', 16),('uint16', 16),\
+                ('int32', 32),('uint32', 32), ('int64', 64),('uint64', 64),\
+                ('byte', 8), ('char', 8)]
+        b = [b for t, b in bits if t == type_][0]
+        import math
+        if type_[0] == 'u' or type_ == 'char':
+            lower = 0
+            upper = int(math.pow(2, b)-1)
+        else:
+            upper = int(math.pow(2, b-1)-1)   
+            lower = -upper - 1 #two's complement min
+        val = int(val) #python will autocast to long if necessary
+        if val > upper or val < lower:
+            raise MsgSpecException("cannot coerce [%s] to %s (out of bounds)"%(val, type_))
+        return val
+    elif type_ == 'bool':
+        # TODO: need to nail down constant spec for bool
+        return True if eval(val) else False
+    raise MsgSpecException("invalid constant type: [%s]"%type_)
+        
+def load_by_type(msgtype, package_context=''):
+    """
+    Load message specification for specified type
+    
+    @param package_context: package name to use for the type name or
+        '' to use the local (relative) naming convention.
+    @type  package_context: str
+    @return: Message type name and message specification
+    @rtype: (str, L{MsgSpec})
+    """
+    pkg, basetype = roslib_electric.names.package_resource_name(msgtype)
+    pkg = pkg or package_context # convert '' -> local package
+    try:
+        m_f = msg_file(pkg, basetype)
+    except roslib_electric.packages.InvalidROSPkgException:
+        raise MsgSpecException("Cannot locate message type [%s], package [%s] does not exist"%(msgtype, pkg)) 
+    return load_from_file(m_f, pkg)
+
+def load_from_string(text, package_context='', full_name='', short_name=''):
+    """
+    Load message specification from a string.
+    @param text: .msg text 
+    @type  text: str
+    @param package_context: package name to use for the type name or
+        '' to use the local (relative) naming convention.
+    @type  package_context: str
+    @return: Message specification
+    @rtype: L{MsgSpec}
+    @raise MsgSpecException: if syntax errors or other problems are detected in file
+    """
+    types = []
+    names = []
+    constants = []
+    for orig_line in text.split('\n'):
+        l = orig_line.split(COMMENTCHAR)[0].strip() #strip comments
+        if not l:
+            continue #ignore empty lines
+        splits = [s for s in [x.strip() for x in l.split(" ")] if s] #split type/name, filter out empties
+        type_ = splits[0]
+        if not is_valid_msg_type(type_):
+            raise MsgSpecException("%s is not a legal message type"%type_)
+        if CONSTCHAR in l:
+            if not is_valid_constant_type(type_):
+                raise MsgSpecException("%s is not a legal constant type"%type_)
+            if type_ == 'string':
+                # strings contain anything to the right of the equals sign, there are no comments allowed
+                idx = orig_line.find(CONSTCHAR)
+                name = orig_line[orig_line.find(' ')+1:idx]
+                val = orig_line[idx+1:]
+            else:
+                splits = [x.strip() for x in ' '.join(splits[1:]).split(CONSTCHAR)] #resplit on '='
+                if len(splits) != 2:
+                    raise MsgSpecException("Invalid declaration: %s"%l)
+                name = splits[0]
+                val = splits[1]
+            try:
+                val_converted  = _convert_val(type_, val)
+            except Exception as e:
+                raise MsgSpecException("Invalid declaration: %s"%e)
+            constants.append(Constant(type_, name, val_converted, val.strip()))
+        else:
+            if len(splits) != 2:
+                raise MsgSpecException("Invalid declaration: %s"%l)
+            name = splits[1]
+            if not is_valid_msg_field_name(name):
+                raise MsgSpecException("%s is not a legal message field name"%name)
+            if package_context and not SEP in type_:
+                if not base_msg_type(type_) in RESERVED_TYPES:
+                    #print "rewrite", type_, "to", "%s/%s"%(package_context, type_)
+                    type_ = "%s/%s"%(package_context, type_)
+            types.append(type_)
+            names.append(name)
+    return MsgSpec(types, names, constants, text, full_name, short_name, package_context)
+
+def load_from_file(file_path, package_context=''):
+    """
+    Convert the .msg representation in the file to a MsgSpec instance.
+    This does *not* register the object.
+    @param file_path: path of file to load from
+    @type  file_path: str:
+    @param package_context: package name to prepend to type name or
+        '' to use local (relative) naming convention.
+    @type  package_context: str
+    @return: Message type name and message specification
+    @rtype:  (str, L{MsgSpec})
+    @raise MsgSpecException: if syntax errors or other problems are detected in file
+    """
+    if VERBOSE:
+        if package_context:
+            print("Load spec from", file_path, "into package [%s]"%package_context)
+        else:
+            print("Load spec from", file_path)
+
+    file_name = os.path.basename(file_path)
+    type_ = file_name[:-len(EXT)]
+    base_type_ = type_
+    # determine the type name
+    if package_context:
+        while package_context.endswith(SEP):
+            package_context = package_context[:-1] #strip message separators
+        type_ = "%s%s%s"%(package_context, SEP, type_)
+    if not roslib_electric.names.is_legal_resource_name(type_):
+        raise MsgSpecException("%s: [%s] is not a legal type name"%(file_path, type_))
+    
+    f = open(file_path, 'r')
+    try:
+        try:
+            text = f.read()
+            return (type_, load_from_string(text, package_context, type_, base_type_))
+        except MsgSpecException as e:
+            raise MsgSpecException('%s: %s'%(file_name, e))
+    finally:
+        f.close()
+
+# data structures and builtins specification ###########################
+
+# adjustable constants, in case we change our minds
+HEADER   = 'Header'
+TIME     = 'time'
+DURATION = 'duration'
+
+def is_header_type(type_):
+    """
+    @param type_: message type name
+    @type  type_: str
+    @return: True if \a type_ refers to the ROS Header type
+    @rtype:  bool
+    """
+    # for backwards compatibility, include roslib/Header. REP 100
+    return type_ in [HEADER, 'std_msgs/Header', 'roslib/Header']
+       
+# time and duration types are represented as aggregate data structures
+# for the purposes of serialization from the perspective of
+# roslib_electric.msgs. genmsg_py will do additional special handling is required
+# to convert them into rospy.msg.Time/Duration instances.
+
+## time as msg spec. time is unsigned 
+TIME_MSG     = "uint32 secs\nuint32 nsecs"
+## duration as msg spec. duration is just like time except signed
+DURATION_MSG = "int32 secs\nint32 nsecs"
+
+## primitive types are those for which we allow constants, i.e. have  primitive representation
+PRIMITIVE_TYPES = ['int8','uint8','int16','uint16','int32','uint32','int64','uint64','float32','float64',
+                   'string',
+                   'bool',
+                   # deprecated:
+                   'char','byte']
+BUILTIN_TYPES = PRIMITIVE_TYPES + [TIME, DURATION]
+
+def is_builtin(msg_type_name):
+    """
+    @param msg_type_name: name of message type
+    @type  msg_type_name: str
+    @return: True if msg_type_name is a builtin/primitive type
+    @rtype: bool
+    """
+    return msg_type_name in BUILTIN_TYPES
+
+## extended builtins are builtin types that can be represented as MsgSpec instances
+EXTENDED_BUILTINS = { TIME : load_from_string(TIME_MSG), DURATION: load_from_string(DURATION_MSG) }
+
+RESERVED_TYPES  = BUILTIN_TYPES + [HEADER]
+
+REGISTERED_TYPES = { } 
+_loaded_packages = [] #keep track of packages so that we only load once (note: bug #59)
+
+def is_registered(msg_type_name):
+    """
+    @param msg_type_name: name of message type
+    @type  msg_type_name: str
+    @return: True if msg spec for specified msg type name is
+    registered. NOTE: builtin types are not registered.
+    @rtype: bool
+    """
+    return msg_type_name in REGISTERED_TYPES
+
+def get_registered(msg_type_name, default_package=None):
+    """
+    @param msg_type_name: name of message type
+    @type  msg_type_name: str
+    @return: msg spec for msg type name
+    @rtype: L{MsgSpec}
+    """
+    if msg_type_name in REGISTERED_TYPES:
+        return REGISTERED_TYPES[msg_type_name]
+    elif default_package:
+        # if msg_type_name has no package specifier, try with default package resolution
+        p, n = roslib_electric.names.package_resource_name(msg_type_name)
+        if not p:
+            return REGISTERED_TYPES[roslib_electric.names.resource_name(default_package, msg_type_name)]
+    raise KeyError(msg_type_name)
+
+def register(msg_type_name, msg_spec):
+    """
+    Load MsgSpec into the type dictionary
+    
+    @param msg_type_name: name of message type
+    @type  msg_type_name: str
+    @param msg_spec: spec to load
+    @type  msg_spec: L{MsgSpec}
+    """
+    if VERBOSE:
+        print("Register msg %s"%msg_type_name)
+    REGISTERED_TYPES[msg_type_name] = msg_spec
+
diff -r cc8bd7a5eafb roslib_electric/src/roslib_electric/names.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/src/roslib_electric/names.py	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,416 @@
+# Software License Agreement (BSD License)
+#
+# Copyright (c) 2008, Willow Garage, Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+#  * Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#  * Redistributions in binary form must reproduce the above
+#    copyright notice, this list of conditions and the following
+#    disclaimer in the documentation and/or other materials provided
+#    with the distribution.
+#  * Neither the name of Willow Garage, Inc. nor the names of its
+#    contributors may be used to endorse or promote products derived
+#    from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+# Revision $Id: names.py 14589 2011-08-07 18:30:21Z kwc $
+
+"""
+Library for manipulating ROS Names. See U{http://ros.org/wiki/Names}.
+"""
+
+import os
+import sys
+
+import roslib_electric.exceptions
+from roslib_electric.rosenv import ROS_NAMESPACE
+
+#TODO: why are these here?
+MSG_EXT = '.msg'
+SRV_EXT = '.srv'
+
+#TODO: deprecate PRN_SEPARATOR
+PRN_SEPARATOR = '/'
+TYPE_SEPARATOR = PRN_SEPARATOR #alias
+SEP = '/'
+GLOBALNS = '/'
+PRIV_NAME = '~'
+REMAP = ":="
+ANYTYPE = '*'
+
+if sys.hexversion > 0x03000000: #Python3
+    def isstring(s):
+        return isinstance(s, str) #Python 3.x
+else:
+    def isstring(s):
+        """
+        Small helper version to check an object is a string in a way that works
+        for both Python 2 and 3
+        """
+        return isinstance(s, basestring) #Python 2.x
+
+def get_ros_namespace(env=None, argv=None):
+    """
+    @param env: environment dictionary (defaults to os.environ)
+    @type  env: dict
+    @param argv: command-line arguments (defaults to sys.argv)
+    @type  argv: [str]
+    @return: ROS namespace of current program
+    @rtype: str
+    """    
+    #we force command-line-specified namespaces to be globally scoped
+    if argv is None:
+        argv = sys.argv
+    for a in argv:
+        if a.startswith('__ns:='):
+            return make_global_ns(a[len('__ns:='):])
+    if env is None:
+        env = os.environ
+    return make_global_ns(env.get(ROS_NAMESPACE, GLOBALNS))
+
+def make_caller_id(name):
+    """
+    Resolve a local name to the caller ID based on ROS environment settings (i.e. ROS_NAMESPACE)
+
+    @param name: local name to calculate caller ID from, e.g. 'camera', 'node'
+    @type  name: str
+    @return: caller ID based on supplied local name
+    @rtype: str
+    """    
+    return make_global_ns(ns_join(get_ros_namespace(), name))
+
+def make_global_ns(name):
+    """
+    Convert name to a global name with a trailing namespace separator.
+    
+    @param name: ROS resource name. Cannot be a ~name.
+    @type  name: str
+    @return str: name as a global name, e.g. 'foo' -> '/foo/'.
+        This does NOT resolve a name.
+    @rtype: str
+    @raise ValueError: if name is a ~name 
+    """    
+    if is_private(name):
+        raise ValueError("cannot turn [%s] into a global name"%name)
+    if not is_global(name):
+        name = SEP + name
+    if name[-1] != SEP:
+        name = name + SEP
+    return name
+
+def is_global(name):
+    """
+    Test if name is a global graph resource name.
+    
+    @param name: must be a legal name in canonical form
+    @type  name: str
+    @return: True if name is a globally referenced name (i.e. /ns/name)
+    @rtype: bool
+    """    
+    return name and name[0] == SEP
+
+def is_private(name):
+    """
+    Test if name is a private graph resource name.
+    
+    @param name: must be a legal name in canonical form
+    @type  name: str
+    @return bool: True if name is a privately referenced name (i.e. ~name)
+    """    
+    return name and name[0] == PRIV_NAME
+
+def namespace(name):
+    """
+    Get the namespace of name. The namespace is returned with a
+    trailing slash in order to favor easy concatenation and easier use
+    within the global context.
+        
+    @param name: name to return the namespace of. Must be a legal
+        name. NOTE: an empty name will return the global namespace.
+    @type  name: str
+    @return str: Namespace of name. For example, '/wg/node1' returns '/wg/'. The
+        global namespace is '/'. 
+    @rtype: str
+    @raise ValueError: if name is invalid
+    """    
+    "map name to its namespace"
+    if name is None: 
+        raise ValueError('name')
+    if not isstring(name):
+        raise TypeError('name')
+    if not name:
+        return SEP
+    elif name[-1] == SEP:
+        name = name[:-1]
+    return name[:name.rfind(SEP)+1] or SEP
+
+def ns_join(ns, name):
+    """
+    Join a namespace and name. If name is unjoinable (i.e. ~private or
+    /global) it will be returned without joining
+
+    @param ns: namespace ('/' and '~' are both legal). If ns is the empty string, name will be returned.
+    @type  ns: str
+    @param name str: a legal name
+    @return str: name concatenated to ns, or name if it is
+        unjoinable.
+    @rtype: str
+    """    
+    if is_private(name) or is_global(name):
+        return name
+    if ns == PRIV_NAME:
+        return PRIV_NAME + name
+    if not ns: 
+        return name
+    if ns[-1] == SEP:
+        return ns + name
+    return ns + SEP + name
+
+def load_mappings(argv):
+    """
+    Load name mappings encoded in command-line arguments. This will filter
+    out any parameter assignment mappings (see roslib_electric.param.load_param_mappings()).
+
+    @param argv: command-line arguments
+    @type  argv: [str]
+    @return: name->name remappings. 
+    @rtype: dict {str: str}
+    """    
+    mappings = {}
+    for arg in argv:
+        if REMAP in arg:
+            try:
+                src, dst = [x.strip() for x in arg.split(REMAP)]
+                if src and dst:
+                    if len(src) > 1 and src[0] == '_' and src[1] != '_':
+                        #ignore parameter assignment mappings
+                        pass
+                    else:
+                        mappings[src] = dst
+            except:
+                sys.stderr.write("ERROR: Invalid remapping argument '%s'\n"%arg)
+    return mappings
+
+#######################################################################
+# RESOURCE NAMES
+# resource names refer to entities in a file system
+
+def resource_name(res_pkg_name, name, my_pkg=None):
+    """
+    Convert package name + resource into a fully qualified resource name
+
+    @param res_pkg_name: name of package resource is located in
+    @type  res_pkg_name: str
+    @param name: resource base name
+    @type  name: str
+    @param my_pkg: name of package resource is being referred to
+        in. If specified, name will be returned in local form if 
+        res_pkg_name is my_pkg
+    @type  my_pkg: str
+    @return: name for resource 
+    @rtype: str
+    """    
+    if res_pkg_name != my_pkg:
+        return res_pkg_name+PRN_SEPARATOR+name
+    return name
+
+def resource_name_base(name):
+    """
+    pkg/typeName -> typeName, typeName -> typeName
+    
+    Convert fully qualified resource name into the package-less resource name
+    @param name: package resource name, e.g. 'std_msgs/String'
+    @type  name: str
+    @return: resource name sans package-name scope
+    @rtype: str
+    """    
+
+    return name[name.rfind(PRN_SEPARATOR)+1:]
+
+def resource_name_package(name):
+    """
+    pkg/typeName -> pkg, typeName -> None
+    
+    @param name: package resource name, e.g. 'std_msgs/String'
+    @type  name: str
+    @return: package name of resource
+    @rtype: str
+    """    
+
+    if not PRN_SEPARATOR in name:
+        return None
+    return name[:name.find(PRN_SEPARATOR)]
+
+def package_resource_name(name):
+    """
+    Split a name into its package and resource name parts, e.g. 'std_msgs/String -> std_msgs, String'
+
+    @param name: package resource name, e.g. 'std_msgs/String'
+    @type  name: str
+    @return: package name, resource name
+    @rtype: str
+    @raise ValueError: if name is invalid
+    """    
+    if PRN_SEPARATOR in name:
+        val = tuple(name.split(PRN_SEPARATOR))
+        if len(val) != 2:
+            raise ValueError("invalid name [%s]"%name)
+        else:
+            return val
+    else:
+        return '', name
+
+def _is_safe_name(name, type_name):
+    #windows long-file name length is 255
+    if not isstring(name) or not name or len(name) > 255:
+        return False
+    return is_legal_resource_name(name)
+
+################################################################################
+# NAME VALIDATORS
+
+import re
+#ascii char followed by (alphanumeric, _, /)
+RESOURCE_NAME_LEGAL_CHARS_P = re.compile('^[A-Za-z][\w_\/]*$') 
+def is_legal_resource_name(name):
+    """
+    Check if name is a legal ROS name for filesystem resources
+    (alphabetical character followed by alphanumeric, underscore, or
+    forward slashes). This constraint is currently not being enforced,
+    but may start getting enforced in later versions of ROS.
+
+    @param name: Name
+    @type  name: str
+    """
+    # resource names can be unicode due to filesystem
+    if name is None:
+        return False
+    m = RESOURCE_NAME_LEGAL_CHARS_P.match(name)
+    # '//' check makes sure there isn't double-slashes
+    return m is not None and m.group(0) == name and not '//' in name
+
+#~,/, or ascii char followed by (alphanumeric, _, /)
+NAME_LEGAL_CHARS_P = re.compile('^[\~\/A-Za-z][\w_\/]*$') 
+def is_legal_name(name):
+    """
+    Check if name is a legal ROS name for graph resources
+    (alphabetical character followed by alphanumeric, underscore, or
+    forward slashes). This constraint is currently not being enforced,
+    but may start getting enforced in later versions of ROS.
+
+    @param name: Name
+    @type  name: str
+    """    
+    # should we enforce unicode checks?
+    if name is None:
+        return False
+    # empty string is a legal name as it resolves to namespace
+    if name == '':
+        return True
+    m = NAME_LEGAL_CHARS_P.match(name)
+    return m is not None and m.group(0) == name and not '//' in name
+    
+BASE_NAME_LEGAL_CHARS_P = re.compile('^[A-Za-z][\w_]*$') #ascii char followed by (alphanumeric, _)
+def is_legal_base_name(name):
+    """
+    Validates that name is a legal base name for a graph resource. A base name has
+    no namespace context, e.g. "node_name".
+    """
+    if name is None:
+        return False
+    m = BASE_NAME_LEGAL_CHARS_P.match(name)
+    return m is not None and m.group(0) == name
+
+BASE_RESOURCE_NAME_LEGAL_CHARS_P = re.compile('^[A-Za-z][\w_]*$') #ascii char followed by (alphanumeric, _)
+def is_legal_resource_base_name(name):
+    """
+    Validates that name is a legal resource base name. A base name has
+    no package context, e.g. "String".
+    """
+    # resource names can be unicode due to filesystem
+    if name is None:
+        return False
+    m = BASE_NAME_LEGAL_CHARS_P.match(name)
+    return m is not None and m.group(0) == name
+
+def canonicalize_name(name):
+    """
+    Put name in canonical form. Extra slashes '//' are removed and
+    name is returned without any trailing slash, e.g. /foo/bar
+    @param name: ROS name
+    @type  name: str
+    """
+    if not name or name == SEP:
+        return name
+    elif name[0] == SEP:
+        return '/' + '/'.join([x for x in name.split(SEP) if x])
+    else:
+        return '/'.join([x for x in name.split(SEP) if x])        
+
+def resolve_name(name, namespace_, remappings=None):
+    """
+    Resolve a ROS name to its global, canonical form. Private ~names
+    are resolved relative to the node name. 
+
+    @param name: name to resolve.
+    @type  name: str
+    @param namespace_: node name to resolve relative to.
+    @type  namespace_: str
+    @param remappings: Map of resolved remappings. Use None to indicate no remapping.
+    @return: Resolved name. If name is empty/None, resolve_name
+    returns parent namespace_. If namespace_ is empty/None,
+    @rtype: str
+    """
+    if not name: #empty string resolves to parent of the namespace_
+        return namespace(namespace_)
+
+    name = canonicalize_name(name)
+    if name[0] == SEP: #global name
+        resolved_name = name
+    elif is_private(name): #~name
+        # #3044: be careful not to accidentally make rest of name global
+        resolved_name = canonicalize_name(namespace_ + SEP + name[1:])
+    else: #relative
+        resolved_name = namespace(namespace_) + name
+
+    #Mappings override general namespace-based resolution
+    # - do this before canonicalization as remappings are meant to
+    #   match the name as specified in the code
+    if remappings and resolved_name in remappings:
+        return remappings[resolved_name]
+    else:
+        return resolved_name
+
+def anonymous_name(id):
+    """
+    Generate a ROS-legal 'anonymous' name
+
+    @param id: prefix for anonymous name
+    @type  id: str
+    """
+    import socket, random
+    name = "%s_%s_%s_%s"%(id, socket.gethostname(), os.getpid(), random.randint(0, sys.maxsize))
+    # RFC 952 allows hyphens, IP addrs can have '.'s, both
+    # of which are illegal for ROS names. For good
+    # measure, screen ipv6 ':'. 
+    name = name.replace('.', '_')
+    name = name.replace('-', '_')                
+    return name.replace(':', '_')
+
diff -r cc8bd7a5eafb roslib_electric/src/roslib_electric/network.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/src/roslib_electric/network.py	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,427 @@
+# Software License Agreement (BSD License)
+#
+# Copyright (c) 2008, Willow Garage, Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+#  * Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#  * Redistributions in binary form must reproduce the above
+#    copyright notice, this list of conditions and the following
+#    disclaimer in the documentation and/or other materials provided
+#    with the distribution.
+#  * Neither the name of Willow Garage, Inc. nor the names of its
+#    contributors may be used to endorse or promote products derived
+#    from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+# Revision $Id: network.py 14585 2011-08-05 17:56:51Z kwc $
+
+"""
+Network APIs for ROS-based systems, including IP address and ROS
+TCP header libraries. Because ROS-based runtimes must respect the
+ROS_IP and ROS_HOSTNAME environment variables, ROS-specific APIs
+are necessary for correctly retrieving local IP address
+information.
+
+roslib.network supports the netifaces library as an optional
+add-on. netifaces improves IP address configuration detection.
+"""
+
+import os
+import socket
+import struct
+import sys
+import platform
+
+try:
+    from cStringIO import StringIO #Python 2.x
+    python3 = 0
+except ImportError:
+    from io import BytesIO #Python 3.x
+    python3 = 1
+
+try:
+    import urllib.parse as urlparse
+except ImportError:
+    import urlparse
+
+import roslib_electric.exceptions
+import roslib_electric.rosenv 
+
+SIOCGIFCONF = 0x8912
+SIOCGIFADDR = 0x8915
+if platform.system() == 'FreeBSD':
+    SIOCGIFADDR = 0xc0206921
+    if platform.architecture()[0] == '64bit':
+        SIOCGIFCONF = 0xc0106924
+    else:
+        SIOCGIFCONF = 0xc0086924
+
+if 0:
+    # disabling netifaces as it accounts for 50% of startup latency
+    try:
+        import netifaces
+        _use_netifaces = True
+    except:
+        # NOTE: in rare cases, I've seen Python fail to extract the egg
+        # cache when launching multiple python nodes.  Thus, we do
+        # except-all instead of except ImportError (kwc).
+        _use_netifaces = False
+else:
+    _use_netifaces = False
+
+def parse_http_host_and_port(url):
+    """
+    Convenience routine to handle parsing and validation of HTTP URL
+    port due to the fact that Python only provides easy accessors in
+    Python 2.5 and later. Validation checks that the protocol and host
+    are set.
+    
+    @param url: URL to parse
+    @type  url: str
+    @return: hostname and port number in URL or 80 (default).
+    @rtype: (str, int)
+    @raise ValueError: if the url does not validate
+    """
+    # can't use p.port because that's only available in Python 2.5
+    if not url:
+        raise ValueError('not a valid URL')        
+    p = urlparse.urlparse(url)
+    if not p[0] or not p[1]: #protocol and host
+        raise ValueError('not a valid URL')
+    if ':' in p[1]:
+        hostname, port = p[1].split(':')
+        port = int(port)
+    else: 
+        hostname, port = p[1], 80
+    return hostname, port
+    
+def _is_unix_like_platform():
+    """
+    @return: true if the platform conforms to UNIX/POSIX-style APIs
+    @rtype: bool
+    """
+    #return platform.system() in ['Linux', 'Mac OS X', 'Darwin']
+    return platform.system() in ['Linux', 'FreeBSD']
+
+def get_address_override():
+    """
+    @return: ROS_IP/ROS_HOSTNAME override or None
+    @rtype: str
+    @raise ValueError: if ROS_IP/ROS_HOSTNAME/__ip/__hostname are invalidly specified
+    """
+    # #998: check for command-line remappings first
+    for arg in sys.argv:
+        if arg.startswith('__hostname:=') or arg.startswith('__ip:='):
+            try:
+                _, val = arg.split(':=')
+                return val
+            except: #split didn't unpack properly
+                raise ValueError("invalid ROS command-line remapping argument '%s'"%arg)
+
+    # check ROS_HOSTNAME and ROS_IP environment variables, which are
+    # aliases for each other
+    if roslib_electric.rosenv.ROS_HOSTNAME in os.environ:
+        return os.environ[roslib_electric.rosenv.ROS_HOSTNAME]
+    elif roslib_electric.rosenv.ROS_IP in os.environ:
+        return os.environ[roslib_electric.rosenv.ROS_IP]
+    return None
+
+def is_local_address(hostname):
+    """
+    @param hostname: host name/address
+    @type  hostname: str
+    @return True: if hostname maps to a local address, False otherwise. False conditions include invalid hostnames.
+    """
+    try:
+        reverse_ip = socket.gethostbyname(hostname)
+    except socket.error:
+        return False
+    # 127. check is due to #1260
+    if reverse_ip not in get_local_addresses() and not reverse_ip.startswith('127.'):
+        return False
+    return True
+    
+def get_local_address():
+    """
+    @return: default local IP address (e.g. eth0). May be overriden by ROS_IP/ROS_HOSTNAME/__ip/__hostname
+    @rtype: str
+    """
+    override = get_address_override()
+    if override:
+        return override
+    addrs = get_local_addresses()
+    if len(addrs) == 1:
+        return addrs[0]
+    for addr in addrs:
+        # pick first non 127/8 address
+        if not addr.startswith('127.'):
+            return addr
+    else: # loopback 
+        return '127.0.0.1'
+
+# cache for performance reasons
+_local_addrs = None
+def get_local_addresses():
+    """
+    @return: known local addresses. Not affected by ROS_IP/ROS_HOSTNAME
+    @rtype:  [str]
+    """
+    # cache address data as it can be slow to calculate
+    global _local_addrs
+    if _local_addrs is not None:
+        return _local_addrs
+
+    local_addrs = None
+    if _use_netifaces:
+        # #552: netifaces is a more robust package for looking up
+        # #addresses on multiple platforms (OS X, Unix, Windows)
+        local_addrs = []
+        # see http://alastairs-place.net/netifaces/
+        for i in netifaces.interfaces():
+            try:
+                local_addrs.extend([d['addr'] for d in netifaces.ifaddresses(i)[netifaces.AF_INET]])
+            except KeyError: pass
+    elif _is_unix_like_platform():
+        # unix-only branch
+        # adapted from code from Rosen Diankov (rdiankov@cs.cmu.edu)
+        # and from ActiveState recipe
+
+        import fcntl
+        import array
+
+        ifsize = 32
+        if platform.system() == 'Linux' and platform.architecture()[0] == '64bit':
+            ifsize = 40 # untested
+
+        # 32 interfaces allowed, far more than ROS can sanely deal with
+
+        max_bytes = 32 * ifsize
+        # according to http://docs.python.org/library/fcntl.html, the buffer limit is 1024 bytes
+        buff = array.array('B', '\0' * max_bytes)
+        # serialize the buffer length and address to ioctl
+        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)        
+        info = fcntl.ioctl(sock.fileno(), SIOCGIFCONF,
+                           struct.pack('iL', max_bytes, buff.buffer_info()[0]))
+        retbytes = struct.unpack('iL', info)[0]
+        buffstr = buff.tostring()
+        if platform.system() == 'Linux':
+            local_addrs = [socket.inet_ntoa(buffstr[i+20:i+24]) for i in range(0, retbytes, ifsize)]
+        else:
+            # in FreeBSD, ifsize is variable: 16 + (16 or 28 or 56) bytes
+            # When ifsize is 32 bytes, it contains the interface name and address,
+            # else it contains the interface name and other information
+            # This means the buffer must be traversed in its entirety
+            local_addrs = []
+            bufpos = 0
+            while bufpos < retbytes:
+                bufpos += 16
+                ifreqsize = ord(buffstr[bufpos])
+                if ifreqsize == 16:
+                    local_addrs += [socket.inet_ntoa(buffstr[bufpos+4:bufpos+8])]
+                bufpos += ifreqsize
+    else:
+        # cross-platform branch, can only resolve one address
+        local_addrs = [socket.gethostbyname(socket.gethostname())]
+    _local_addrs = local_addrs
+    return local_addrs
+
+
+def get_bind_address(address=None):
+    """
+    @param address: (optional) address to compare against
+    @type  address: str
+    @return: address TCP/IP sockets should use for binding. This is
+    generally 0.0.0.0, but if \a address or ROS_IP/ROS_HOSTNAME is set
+    to localhost it will return 127.0.0.1
+    @rtype: str
+    """
+    if address is None:
+        address = get_address_override()
+    if address and \
+           (address == 'localhost' or address.startswith('127.')):
+        #localhost or 127/8
+        return '127.0.0.1' #loopback
+    else:
+        return '0.0.0.0'
+
+# #528: semi-complicated logic for determining XML-RPC URI
+def get_host_name():
+    """
+    Determine host-name for use in host-name-based addressing (e.g. XML-RPC URIs):
+     - if ROS_IP/ROS_HOSTNAME is set, use that address
+     - if the hostname returns a non-localhost value, use that
+     - use whatever L{get_local_address()} returns
+    """
+    hostname = get_address_override()
+    if not hostname:
+        try:
+            hostname = socket.gethostname()
+        except:
+            pass
+        if not hostname or hostname == 'localhost' or hostname.startswith('127.'):
+            hostname = get_local_address()
+    return hostname
+
+def create_local_xmlrpc_uri(port):
+    """
+    Determine the XMLRPC URI for local servers. This handles the search
+    logic of checking ROS environment variables, the known hostname,
+    and local interface IP addresses to determine the best possible
+    URI.
+    
+    @param port: port that server is running on
+    @type  port: int
+    @return: XMLRPC URI    
+    @rtype: str
+    """
+    #TODO: merge logic in roslib.xmlrpc with this routine
+    # in the future we may not want to be locked to http protocol nor root path
+    return 'http://%s:%s/'%(get_host_name(), port)
+
+
+## handshake utils ###########################################
+
+class ROSHandshakeException(roslib_electric.exceptions.ROSLibException):
+    """
+    Exception to represent errors decoding handshake
+    """
+    pass
+
+def decode_ros_handshake_header(header_str):
+    """
+    Decode serialized ROS handshake header into a Python dictionary
+
+    header is a list of string key=value pairs, each prefixed by a
+    4-byte length field. It is preceeded by a 4-byte length field for
+    the entire header.
+    
+    @param header_str: encoded header string. May contain extra data at the end.
+    @type  header_str: str
+    @return: key value pairs encoded in \a header_str
+    @rtype: {str: str} 
+    """
+    (size, ) = struct.unpack('<I', header_str[0:4])
+    size += 4 # add in 4 to include size of size field
+    header_len = len(header_str)
+    if size > header_len:
+        raise ROSHandshakeException("Incomplete header. Expected %s bytes but only have %s"%((size+4), header_len))
+
+    d = {}
+    start = 4
+    while start < size:
+        (field_size, ) = struct.unpack('<I', header_str[start:start+4])
+        if field_size == 0:
+            raise ROSHandshakeException("Invalid 0-length handshake header field")
+        start += field_size + 4
+        if start > size:
+            raise ROSHandshakeException("Invalid line length in handshake header: %s"%size)
+        line = header_str[start-field_size:start]
+        
+        #python3 compatibility
+        if python3 == 1:
+            line = line.decode()
+        
+        idx = line.find("=")
+        if idx < 0:
+            raise ROSHandshakeException("Invalid line in handshake header: [%s]"%line)
+        key = line[:idx]
+        value = line[idx+1:]
+        d[key.strip()] = value
+    return d
+    
+def read_ros_handshake_header(sock, b, buff_size):
+    """
+    Read in tcpros header off the socket \a sock using buffer \a b.
+    
+    @param sock: socket must be in blocking mode
+    @type  sock: socket
+    @param b: buffer to use
+    @type  b: StringIO for Python2, BytesIO for Python 3
+    @param buff_size: incoming buffer size to use
+    @type  buff_size: int
+    @return: key value pairs encoded in handshake
+    @rtype: {str: str}
+    @raise ROSHandshakeException: If header format does not match expected
+    """
+    header_str = None
+    while not header_str:
+        d = sock.recv(buff_size)
+        if not d:
+            raise ROSHandshakeException("connection from sender terminated before handshake header received. %s bytes were received. Please check sender for additional details."%b.tell())
+        b.write(d)
+        btell = b.tell()
+        if btell > 4:
+            # most likely we will get the full header in the first recv, so
+            # not worth tiny optimizations possible here
+            bval = b.getvalue()
+            (size,) = struct.unpack('<I', bval[0:4])
+            if btell - 4 >= size:
+                header_str = bval
+                    
+                # memmove the remnants of the buffer back to the start
+                leftovers = bval[size+4:]
+                b.truncate(len(leftovers))
+                b.seek(0)
+                b.write(leftovers)
+                header_recvd = True
+                    
+    # process the header
+    return decode_ros_handshake_header(bval)
+
+def encode_ros_handshake_header(header):
+    """
+    Encode ROS handshake header as a byte string. Each header
+    field is a string key value pair. The encoded header is
+    prefixed by a length field, as is each field key/value pair.
+    key/value pairs a separated by a '=' equals sign.
+
+    FORMAT: (4-byte length + [4-byte field length + field=value ]*)
+
+    @param header: header field keys/values
+    @type  header: dict
+    @return: header encoded as byte string
+    @rtype: str
+    """    
+    fields = ["%s=%s"%(k,v) for k,v in header.items()]
+    
+    # in the usual configuration, the error 'TypeError: can't concat bytes to str' appears:
+    if python3 == 0:
+        #python 2
+        s = ''.join(["%s%s"%(struct.pack('<I', len(f)), f) for f in fields])
+        return struct.pack('<I', len(s)) + s
+    else:
+        #python 3 
+        s = b''.join([(struct.pack('<I', len(f)) + f.encode("utf-8")) for f in fields])
+        return struct.pack('<I', len(s)) + s
+                                        
+def write_ros_handshake_header(sock, header):
+    """
+    Write ROS handshake header header to socket sock
+    @param sock: socket to write to (must be in blocking mode)
+    @type  sock: socket.socket
+    @param header: header field keys/values
+    @type  header: {str : str}
+    @return: Number of bytes sent (for statistics)
+    @rtype: int
+    """
+    s = encode_ros_handshake_header(header)
+    sock.sendall(s)
+    return len(s) #STATS
+    
diff -r cc8bd7a5eafb roslib_electric/src/roslib_electric/os_detect.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/src/roslib_electric/os_detect.py	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,577 @@
+#!/usr/bin/env python
+# Copyright (c) 2009, Willow Garage, Inc.
+# All rights reserved.
+# 
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are met:
+# 
+#     * Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#     * Redistributions in binary form must reproduce the above copyright
+#       notice, this list of conditions and the following disclaimer in the
+#       documentation and/or other materials provided with the distribution.
+#     * Neither the name of the Willow Garage, Inc. nor the names of its
+#       contributors may be used to endorse or promote products derived from
+#       this software without specific prior written permission.
+# 
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+# Author Tully Foote/tfoote@willowgarage.com
+
+"""
+Library for detecting the current OS, including detecting specific
+Linux distributions. 
+
+The APIs of this library are still very coupled with the rosdep 
+command-line tool.
+"""
+
+import roslib_electric.exceptions
+import os
+import sys
+import subprocess
+import types
+import tempfile
+import distutils.version # To parse version numbers
+
+if sys.hexversion > 0x03000000: #Python3
+    python3 = True
+else:
+    python3 = False
+
+####### Linux Helper Functions #####
+def _read_stdout(cmd):
+    pop = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
+    (std_out, std_err) = pop.communicate()
+    if python3:
+        return std_out.decode()
+    else:
+        return std_out
+    
+def lsb_get_os():
+    """
+    Linux: wrapper around lsb_release to get the current OS
+    """
+    try:
+        return _read_stdout(['lsb_release', '-si']).strip()
+    except:
+        return None
+    
+def lsb_get_codename():
+    """
+    Linux: wrapper around lsb_release to get the current OS codename
+    """
+    try:
+        return _read_stdout(['lsb_release', '-sc']).strip()
+    except:
+        return None
+    
+def lsb_get_version():
+    """
+    Linux: wrapper around lsb_release to get the current OS version
+    """
+    try:
+        return _read_stdout(['lsb_release', '-sr']).strip()
+    except:
+        return None
+
+def uname_get_machine():
+    """
+    Linux: wrapper around uname to determine if OS is 64-bit
+    """
+    try:
+        return _read_stdout(['uname', '-m']).strip()
+    except:
+        return None
+
+
+
+#### Override class for debugging and unsupported OSs ###########
+class OSOverride:
+    def __init__(self):
+        self._os_name = "uninitialized from ROS_OS_OVERRIDE=name:version"
+        self._os_version = "uninitialized from ROS_OS_OVERRIDE=name:version"
+        
+    def check_presence(self):
+        try:
+            (self._os_name, self._os_version) = os.environ["ROS_OS_OVERRIDE"].split(':')
+            sys.stderr.write("Using environment variable ROS_OS_OVERRIDE name = %s version = %s\n"%(self._os_name, self._os_version))
+            return True
+        except:
+            return False
+    
+    def get_version(self):
+        return self._os_version
+
+    def get_name(self):
+        return self._os_name
+
+
+class OSDetectException(roslib_electric.exceptions.ROSLibException): pass
+
+class OSBase:
+    """
+    This defines the API used for OS detection within the os_detect
+    module for roslib_electric.  All OS specific instantiantions must inherit
+    and override these methods.
+    """
+    def check_presence(self):
+        """
+        Return if the specific OS which this class is designed to
+        detect is present.  Only one version of this class should return for
+        any version.  
+        """
+        raise OSDetectException("check_presence unimplemented")
+
+    def get_name(self):
+        """
+        Return the standardized name for this OS.  (ala Ubuntu Hardy Heron = "ubuntu")
+        """
+        raise OSDetectException("get_name unimplemented")
+
+    def get_version(self):
+        """
+        Return the standardized version for this OS. (ala Ubuntu Hardy Heron = "8.04")
+        """
+        raise OSDetectException("get_version unimplemented")
+
+
+###### Debian SPECIALIZATION #########################
+class Debian(OSBase):
+    """
+    Detect Debian OS.
+    """
+    def check_presence(self):
+        if "Debian" == lsb_get_os():
+            return True
+        return False
+
+    def get_version(self):
+        return lsb_get_codename()
+    def get_name(self):
+        return "debian"
+
+###### END Debian SPECIALIZATION ########################
+
+###### Mandriva SPECIALIZATION #########################
+class Mandriva(OSBase):
+    """
+    Detect Mandriva OS. The returned version will be the year release (e.g.
+    2010.0) concatenated with the machine architecture (e.g. x86_64), resulting
+    in something like 2010.0x86_64.
+    """
+    def check_presence(self):
+        if "MandrivaLinux" == lsb_get_os():
+            return True
+        return False
+    
+    def get_version(self):
+        return lsb_get_version()+uname_get_machine()
+    def get_name(self):
+        return "mandriva"
+
+###### END Mandriva SPECIALIZATION ########################
+
+
+
+###### UBUNTU SPECIALIZATION #########################
+class Ubuntu(Debian):
+    """ This is an implementation of a standard interface for
+    interacting with rosdep.  This defines all Ubuntu sepecific
+    methods, including detecting the OS/Version number.  As well as
+    how to check for and install packages."""
+    def check_presence(self):
+        if "Ubuntu" == lsb_get_os():
+            return True
+        return False
+
+    def get_version(self):
+        return lsb_get_codename()
+    def get_name(self):
+        return "ubuntu"
+
+###### END UBUNTU SPECIALIZATION ########################
+
+###### Mint SPECIALIZATION #########################
+class Mint(OSBase):
+    """
+    Detect Mint variants of Debian.
+    """
+    def check_presence(self):
+        if "LinuxMint" == lsb_get_os():
+            return True
+        return False
+
+    def get_version(self):
+        return lsb_get_version()
+
+    def get_name(self):
+        return "mint"
+###### END Mint SPECIALIZATION ########################
+
+###### OpenSuse SPECIALIZATION #########################
+class OpenSuse(OSBase):
+    """
+    Detect OpenSuse OS.
+    """
+    def check_presence(self):
+        try:
+            filename = "/etc/SuSE-brand"
+            if os.path.exists(filename):
+                with open(filename, 'r') as fh:
+                    os_list = fh.read().split()
+                    if len(os_list) > 0 and os_list[0] == "openSUSE":
+                        return True
+        except:
+            pass
+        return False
+
+    def get_version(self):
+        try:
+            filename = "/etc/SuSE-brand"
+            if os.path.exists(filename):
+                with open(filename, 'r') as fh:
+                    os_list = fh.read().strip().split('\n')
+                    if len(os_list) == 2:
+                        os_list = os_list[1].split(' = ')
+                        if os_list[0] == "VERSION":
+                            return os_list[1]
+        except:
+            return False
+        
+        return False
+
+    def get_name(self):
+        return "opensuse"
+
+###### END OpenSuse SPECIALIZATION ########################
+
+
+###### Fedora SPECIALIZATION #########################
+class Fedora(OSBase):
+    """
+    Detect Fedora OS.
+    """
+    def check_presence(self):
+        try:
+            filename = "/etc/redhat-release"
+            if os.path.exists(filename):
+                with open(filename, 'r') as fh:                
+                    os_list = fh.read().split()
+                if os_list and os_list[0] == "Fedora" and os_list[1] == "release":
+                    return True
+        except:
+            pass
+        return False
+
+    def get_version(self):
+        try:
+            filename = "/etc/issue"
+            if os.path.exists(filename):
+                with open(filename, 'r') as fh:
+                    os_list = fh.read().split()
+                if os_list[0] == "Fedora" and os_list[1] == "release":
+                    return os_list[2]
+        except:
+            sys.stderr.write("Fedora failed to get version\n")
+            return False
+
+        return False
+
+    def get_name(self):
+        return "fedora"
+
+###### END Fedora SPECIALIZATION ########################
+
+###### Rhel SPECIALIZATION #########################
+class Rhel(Fedora):
+    """
+    Detect Redhat OS.
+    """
+    def check_presence(self):
+        try:
+            filename = "/etc/redhat-release"
+            if os.path.exists(filename):
+                with open(filename, 'r') as fh:                
+                    os_list = fh.read().split()
+                if os_list and os_list[2] == "Enterprise":
+                    return True
+        except:
+            pass
+        return False
+
+    def get_version(self):
+        try:
+            filename = "/etc/issue"
+            if os.path.exists(filename):
+                with open(filename, 'r') as fh:
+                    os_list = fh.read().split()
+                if os_list and os_list[2] == "Enterprise":
+                    return os_list[6]
+        except:
+            sys.stderr.write("Rhel failed to get version\n")
+            return False
+
+        return False
+
+    def get_name(self):
+        return "rhel"
+
+###### END Rhel SPECIALIZATION ########################
+
+###### OSX SPECIALIZATION #########################
+def port_detect(p):
+    """
+    Detect presence of Macports by running "port installed" command.
+    """
+    std_out = _read_stdout(['port', 'installed', p])
+    return (std_out.count("(active)") > 0)
+
+class Osx(OSBase):
+    """
+    Detect OS X 
+    """
+    def check_presence(self):
+        filename = "/usr/bin/sw_vers"
+        if os.path.exists(filename):
+            return True
+        return False
+    
+    def get_version(self):
+        # REP 111 this should be the code name (e.g., lion, snow, tiger) #3570
+        std_out = _read_stdout(['/usr/bin/sw_vers','-productVersion'])
+        ver = distutils.version.StrictVersion(std_out).version
+        if len(ver) < 2:
+            raise OSDetectException("invalid version string: %s"%(std_out))
+        major, minor = ver[0:2]
+        # Source: http://en.wikipedia.org/wiki/Mac_OS_X#Versions
+        if major == 10 and minor == 4:
+            return 'tiger'
+        elif major == 10 and minor == 5:
+            return 'leopard'
+        elif major == 10 and minor == 6:
+            return 'snow'
+        elif major == 10 and minor == 7:
+            return 'lion'
+        else:
+            raise OSDetectException("unrecognized version: %s"%(std_out))
+
+    def get_name(self):
+        return "osx"
+
+class OsxBrew(OSBase):
+    """
+    Detect OS X 
+    """
+
+    def check_presence(self):
+        # not enabled for ROS Electric.  Only enabled under override.
+        return False
+    
+    def get_version(self):
+        # REP 111 this should be the code name (e.g., lion, snow, tiger) #3570
+        std_out = _read_stdout(['/usr/bin/sw_vers','-productVersion'])
+        ver = distutils.version.StrictVersion(std_out).version
+        if len(ver) < 2:
+            raise OSDetectException("invalid version string: %s"%(std_out))
+        major, minor = ver[0:2]
+        # Source: http://en.wikipedia.org/wiki/Mac_OS_X#Versions
+        if major == 10 and minor == 4:
+            return 'tiger'
+        elif major == 10 and minor == 5:
+            return 'leopard'
+        elif major == 10 and minor == 6:
+            return 'snow'
+        elif major == 10 and minor == 7:
+            return 'lion'
+        else:
+            raise OSDetectException("unrecognized version: %s"%(std_out))
+
+    def get_name(self):
+        return "osxbrew"
+
+###### END OSX SPECIALIZATION ########################
+
+###### Arch SPECIALIZATION #########################
+class Arch(OSBase):
+    """
+    Detect Arch Linux.
+    """
+
+    def check_presence(self):
+        filename = "/etc/arch-release"
+        if os.path.exists(filename):
+            return True
+        return False
+
+    def get_version(self):
+        return ""
+
+    def get_name(self):
+        return "arch"
+
+###### END Arch SPECIALIZATION ########################
+
+
+###### Cygwin SPECIALIZATION #########################
+class Cygwin(OSBase):
+    """
+    Detect Cygwin presence on Windows OS.
+    """
+    def check_presence(self):
+        filename = "/usr/bin/cygwin1.dll"
+        if os.path.exists(filename):
+            return True
+        return False
+    
+    def get_version(self):
+        return _read_stdout(['uname','-r']).strip()
+
+    def get_name(self):
+        return "cygwin"
+
+###### END Cygwin SPECIALIZATION ########################
+
+###### Gentoo Sepcialization ###############################
+class Gentoo(OSBase):
+    """
+    Detect Gentoo OS.
+    """
+    def check_presence(self):
+        try:
+            filename = "/etc/gentoo-release"
+            if os.path.exists(filename):
+                with open(filename, 'r') as fh:                
+                    os_list = fh.read().split()
+                if os_list and os_list[0] == "Gentoo" and os_list[1] == "Base":
+                    return True
+        except:
+            pass
+        return False
+
+    def get_version(self):
+        try:
+            filename = "/etc/gentoo-release"
+            if os.path.exists(filename):
+                with open(filename, 'r') as fh:
+                    os_list = fh.read().split()
+                if os_list[0] == "Gentoo" and os_list[1] == "Base":
+                    return os_list[4]
+        except:
+            sys.stderr.write("Gentoo failed to get version\n")
+            return False
+
+        return False
+
+    def get_name(self):
+        return "gentoo"
+
+###### END Gentoo Sepcialization ###############################
+
+###### FreeBSD SPECIALIZATION #########################
+class FreeBSD(OSBase):
+    """
+    Detect FreeBSD OS.
+    """
+    def check_presence(self):
+        try:
+            filename = "/usr/bin/uname"
+            if os.path.exists(filename):
+                std_out = _read_stdout([filename])
+                if std_out.strip() == "FreeBSD":
+                    return True
+            else:
+                return False
+        except:
+            pass#print >> sys.stderr, "FreeBSD failed to detect OS"
+        return False
+
+    def get_version(self):
+        try:
+            filename = "/usr/bin/uname"
+            if os.path.exists(filename):
+                return _read_stdout([filename, "-r"]).strip()
+            else:
+                return False
+        except:
+            sys.stderr.write("FreeBSD failed to get version\n")
+            return False
+
+        return False
+
+    def get_name(self):
+        return "freebsd"
+
+###### FreeBSD SPECIALIZATION #########################
+
+    
+
+
+
+
+class OSDetect:
+    """ This class will iterate over registered classes to lookup the
+    active OS and version"""
+    def __init__(self, os_list = [Debian(), Mandriva(), Ubuntu(), Mint(), Osx(), OsxBrew(), Arch(), OpenSuse(), Fedora(), Rhel(), Gentoo(), Cygwin(), FreeBSD()]):
+        self._os_list = os_list
+        for o in self._os_list:
+            if not isinstance(o, OSBase):
+                raise OSDetectException("Class [%s] not derived from OSBase"%o.__class__.__name__)
+
+        self._os_class = None
+        self._os_name = None
+        self._os_version = None
+
+        self.detect_os()
+
+    def add_os(self, class_ref):
+        self._os_list.append(class_ref)
+
+        # \TODO look at throwing here
+    def detect_os(self):
+        override = OSOverride()
+        if override.check_presence():
+            for os_class in self._os_list:
+                if os_class.get_name() == override.get_name():
+                    self._os_name = override.get_name()
+                    self._os_version = override.get_version()
+                    self._os_class = os_class
+                    return True
+
+        for os_class in self._os_list:
+            if os_class.check_presence():
+                self._os_name = os_class.get_name()
+                self._os_version = os_class.get_version()
+                self._os_class = os_class
+                return True
+
+        # No solution found
+        attempted_oss = [o.get_name() for o in self._os_list]
+        raise OSDetectException("Could not detect OS, tried %s"%attempted_oss)
+        return False
+
+    def get_os(self):
+        if not self._os_class:
+            self.detect_os()
+        return self._os_class
+
+    def get_name(self):
+        if not self._os_name:
+            self.detect_os()
+        return self._os_name
+
+    def get_version(self):
+        if not self._os_version:
+            not self.detect_os()
+        return self._os_version
+
diff -r cc8bd7a5eafb roslib_electric/src/roslib_electric/packages.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/src/roslib_electric/packages.py	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,797 @@
+# Software License Agreement (BSD License)
+#
+# Copyright (c) 2008, Willow Garage, Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+#  * Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#  * Redistributions in binary form must reproduce the above
+#    copyright notice, this list of conditions and the following
+#    disclaimer in the documentation and/or other materials provided
+#    with the distribution.
+#  * Neither the name of Willow Garage, Inc. nor the names of its
+#    contributors may be used to endorse or promote products derived
+#    from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+# Revision $Id: packages.py 14579 2011-08-05 17:31:05Z kwc $
+# $Author: kwc $
+
+"""
+Python utilities for manipulating ROS packages.
+See: U{http://ros.org/wiki/Packages}
+
+Warning: while most of this API is stable, some parts are still fairly
+experimental and incomplete. In particular, the L{ROSPackages} class
+in very experimental.
+"""
+
+from __future__ import with_statement
+
+import os
+import sys
+import stat
+import string
+
+from subprocess import Popen, PIPE
+
+import roslib_electric.exceptions
+import roslib_electric.manifest
+import roslib_electric.names
+import roslib_electric.rosenv
+import roslib_electric.os_detect
+
+MSG_DIR = 'msg'
+SRV_DIR = 'srv'
+SRC_DIR = 'src'
+
+# aliases
+ROS_PACKAGE_PATH = roslib_electric.rosenv.ROS_PACKAGE_PATH
+ROS_ROOT = roslib_electric.rosenv.ROS_ROOT
+
+class ROSPkgException(roslib_electric.exceptions.ROSLibException):
+    """
+    Base class of package-related errors.
+    """
+    pass
+class InvalidROSPkgException(ROSPkgException):
+    """
+    Exception that indicates that a ROS package does not exist
+    """
+    pass
+class MultipleNodesException(ROSPkgException):
+    """
+    Exception that indicates that multiple ROS nodes by the same name are in the same package.
+    """
+    pass
+
+# TODO: go through the code and eliminate unused methods -- there's far too many combos here
+
+MANIFEST_FILE = 'manifest.xml'
+
+#
+# Map package/directory structure
+#
+
+def is_pkg_dir(d):
+    """
+    @param d: directory location
+    @type  d: str
+    @return: True if d is the root directory of a ROS Package
+    @rtype: bool
+    """
+    return os.path.isfile(os.path.join(d, MANIFEST_FILE))
+
+def get_package_paths(ros_root_required=True, env=None):
+    """
+    Get the paths to search for packages
+    
+    @param ros_root_required: if True, raise exception if
+    environment is invalid (i.e. ROS_ROOT is not set properly)
+    @type  ros_root_required: bool
+    @param env: override os.environ dictionary
+    @type  env: dict
+    @raise roslib_electric.rosenv.ROSEnvException: if ros_root_required is True
+    and ROS_ROOT is not set
+    """
+    if env is None:
+        env = os.environ
+    rpp = roslib_electric.rosenv.get_ros_package_path(required=False, env=env)
+    if rpp:
+        paths = [x for x in rpp.split(os.pathsep) if x]
+    else:
+        paths = []
+    rr_path = roslib_electric.rosenv.get_ros_root(required=ros_root_required, env=env)
+    if rr_path:
+        return paths + [rr_path]
+    else:
+        return paths
+
+def get_dir_pkg(d):
+    """
+    Get the package that the directory is contained within. This is
+    determined by finding the nearest parent manifest.xml file. This
+    isn't 100% reliable, but symlinks can full any heuristic that
+    relies on ROS_ROOT.
+    @param d: directory path
+    @type  d: str
+    @return: (package_directory, package) of the specified directory, or None,None if not in a package
+    @rtype: (str, str)
+    """
+    #TODO: the realpath is going to create issues with symlinks, most likely
+
+    parent = os.path.dirname(os.path.realpath(d))
+    #walk up until we hit ros root or ros/pkg
+    while not os.path.exists(os.path.join(d, MANIFEST_FILE)) and parent != d:
+        d = parent
+        parent = os.path.dirname(d)
+    if os.path.exists(os.path.join(d, MANIFEST_FILE)):
+        pkg = os.path.basename(os.path.abspath(d))
+        return d, pkg
+    return None, None
+
+_pkg_dir_cache = {}
+
+def get_pkg_dir(package, required=True, ros_root=None, ros_package_path=None):
+    """
+    Locate directory package is stored in. This routine uses an
+    internal cache.
+
+    NOTE: cache does *not* rebuild if packages are relocated after
+    this process is initiated.
+    
+    @param package: package name
+    @type  package: str
+    @param required: if True, an exception will be raised if the
+    package directory cannot be located.
+    @type  required: bool
+    @param ros_root: if specified, override ROS_ROOT
+    @type  ros_root: str
+    @param ros_package_path: if specified, override ROS_PACKAGE_PATH
+    @type  ros_package_path: str
+    @return: directory containing package or None if package cannot be found and required is False.
+    @rtype: str
+    @raise InvalidROSPkgException: if required is True and package cannot be located
+    """    
+
+    #UNIXONLY
+    #TODO: replace with non-rospack-based solution (e.g. os.walk())
+    try:
+        penv = os.environ.copy()
+        if ros_root:
+            ros_root = roslib_electric.rosenv.resolve_path(ros_root)
+            penv[ROS_ROOT] = ros_root
+        elif ROS_ROOT in os.environ:
+            # record setting for _pkg_dir_cache
+            ros_root = os.environ[ROS_ROOT]
+        if ros_root:
+            rospack = os.path.join(ros_root, 'bin', 'rospack')
+        else:
+            rospack = 'rospack'
+
+        if 'ROS_BUILD' in os.environ:
+            rospack = os.path.join(os.environ['ROS_BUILD'], 'bin', 'rospack')
+
+        if ros_package_path is not None:
+            ros_package_path = roslib_electric.rosenv.resolve_paths(ros_package_path)
+            penv[ROS_PACKAGE_PATH] = ros_package_path
+        elif ROS_PACKAGE_PATH in os.environ:
+            # record setting for _pkg_dir_cache
+            ros_package_path = os.environ[ROS_PACKAGE_PATH]
+
+        # update cache if we haven't. NOTE: we only get one cache
+        if not _pkg_dir_cache:
+            _read_rospack_cache(_pkg_dir_cache, ros_root, ros_package_path)
+            
+        # now that we've resolved the args, check the cache
+        if package in _pkg_dir_cache:
+            dir_, rr, rpp = _pkg_dir_cache[package]
+            if rr == ros_root and rpp == ros_package_path:
+                if os.path.isfile(os.path.join(dir_, MANIFEST_FILE)):
+                    return dir_
+                else:
+                    # invalidate cache
+                    _invalidate_cache(_pkg_dir_cache)
+            
+        rpout, rperr = Popen([rospack, 'find', package], \
+                                 stdout=PIPE, stderr=PIPE, env=penv).communicate()
+
+        pkg_dir = (rpout or '').strip()
+        #python3.1 popen returns as bytes
+        if (isinstance(pkg_dir, bytes)):
+            pkg_dir = pkg_dir.decode()
+        if not pkg_dir:
+            raise InvalidROSPkgException("Cannot locate installation of package %s: %s. ROS_ROOT[%s] ROS_PACKAGE_PATH[%s]"%(package, rperr.strip(), ros_root, ros_package_path))
+
+        if not os.path.exists(pkg_dir):
+            raise InvalidROSPkgException("Cannot locate installation of package %s: [%s] is not a valid path. ROS_ROOT[%s] ROS_PACKAGE_PATH[%s]"%(package, pkg_dir, ros_root, ros_package_path))
+        elif not os.path.isdir(pkg_dir):
+            raise InvalidROSPkgException("Package %s is invalid: file [%s] is in the way"%(package, pkg_dir))
+        # don't update cache: this should only be updated from
+        # rospack_cache as it will corrupt list_pkgs() otherwise.
+        #_pkg_dir_cache[package] = (pkg_dir, ros_root, ros_package_path)
+        return pkg_dir
+    except OSError as e:
+        if required:
+            raise InvalidROSPkgException("Environment configuration is invalid: cannot locate rospack (%s)"%e)
+        return None
+    except Exception as e:
+        if required:
+            raise
+        return None
+
+def _get_pkg_subdir_by_dir(package_dir, subdir, required=True, env=None):
+    """
+    @param required: if True, will attempt to  create the subdirectory
+        if it does not exist. An exception will be raised  if this fails.
+    @type  required: bool
+    @param package_dir: directory of package
+    @type  package_dir: str
+    @param subdir: name of subdirectory to locate
+    @type  subdir: str
+    @param env: override os.environ dictionary    
+    @type  env: dict
+    @param required: if True, directory must exist    
+    @type  required: bool
+    @return: Package subdirectory if package exist, otherwise None.
+    @rtype: str
+    @raise InvalidROSPkgException: if required is True and directory does not exist
+    """
+    if env is None:
+        env = os.environ
+    try:
+        if not package_dir:
+            raise Exception("Cannot create a '%(subdir)s' directory in %(package_dir)s: package %(package) cannot be located"%locals())
+        d = os.path.join(package_dir, subdir)
+        if required and os.path.isfile(d):
+            raise Exception("""Package '%(package)s' is improperly configured: 
+file %(d)s is preventing the creation of a directory"""%locals())
+        elif required and not os.path.isdir(d):
+            try:
+                os.makedirs(d) #lazy create
+            except error:
+                raise Exception("""Package '%(package)s' is improperly configured: 
+Cannot create a '%(subdir)s' directory in %(package_dir)s.
+Please check permissions and try again.
+"""%locals())
+        return d
+    except Exception as e:
+        if required:
+            raise
+        return None
+    
+def get_pkg_subdir(package, subdir, required=True, env=None):
+    """
+    @param required: if True, will attempt to create the subdirectory
+        if it does not exist. An exception will be raised  if this fails.
+    @type  required: bool
+    @param package: name of package
+    @type  package: str
+    @param env: override os.environ dictionary
+    @type  env: dict
+    @param required: if True, directory must exist    
+    @type  required: bool
+    @return: Package subdirectory if package exist, otherwise None.
+    @rtype: str
+    @raise InvalidROSPkgException: if required is True and directory does not exist
+    """
+    if env is None:
+        env = os.environ
+    pkg_dir = get_pkg_dir(package, required, ros_root=env[ROS_ROOT]) 
+    return _get_pkg_subdir_by_dir(pkg_dir, subdir, required, env)
+
+#
+# Map ROS resources to files
+#
+
+def resource_file(package, subdir, resource_name):
+    """
+    @param subdir: name of subdir -- these should be one of the
+        string constants, e.g. MSG_DIR
+    @type  subdir: str
+    @return: path to resource in the specified subdirectory of the
+        package, or None if the package does not exists
+    @rtype: str
+    @raise roslib_electric.packages.InvalidROSPkgException: If package does not exist 
+    """
+    d = get_pkg_subdir(package, subdir, False)
+    if d is None:
+        raise InvalidROSPkgException(package)
+    return os.path.join(d, resource_name)
+
+def _update_rospack_cache(env=None):
+    """
+    Internal routine to update global package directory cache
+    
+    @return: True if cache is valid
+    @rtype: bool
+    """
+    if env is None:
+        env = os.environ
+    cache = _pkg_dir_cache
+    if cache:
+        return True
+    ros_root = env[ROS_ROOT]
+    ros_package_path = env.get(ROS_PACKAGE_PATH, '')
+    return _read_rospack_cache(cache, ros_root, ros_package_path)
+
+def _invalidate_cache(cache):
+    # I've only made this a separate routine because roslib_electric.packages should really be using
+    # the roslib_electric.stacks cache implementation instead with the separate cache marker
+    cache.clear()
+
+def _read_rospack_cache(cache, ros_root, ros_package_path):
+    """
+    Read in rospack_cache data into cache. On-disk cache specifies a
+    ROS_ROOT and ROS_PACKAGE_PATH, which must match the requested
+    environment.
+    
+    @param cache: empty dictionary to store package list in. 
+        If no cache argument provided, list_pkgs() will use internal _pkg_dir_cache
+        and will return cached answers if available.
+        The format of the cache is {package_name: dir_path, ros_root, ros_package_path}.
+    @type  cache: {str: str, str, str}
+    @param ros_package_path: ROS_ROOT value
+    @type  ros_root: str
+    @param ros_package_path: ROS_PACKAGE_PATH value or '' if not specified
+    @type  ros_package_path: str
+    @return: True if on-disk cache matches and was loaded, false otherwise
+    @rtype: bool
+    """
+    try:
+        with open(os.path.join(roslib_electric.rosenv.get_ros_home(), 'rospack_cache')) as f:
+            for l in f.readlines():
+                l = l[:-1]
+                if not len(l):
+                    continue
+                if l[0] == '#':
+                    # check that the cache matches our env
+                    if l.startswith('#ROS_ROOT='):
+                        if not l[len('#ROS_ROOT='):] == ros_root:
+                            return False
+                    elif l.startswith('#ROS_PACKAGE_PATH='):
+                        if not l[len('#ROS_PACKAGE_PATH='):] == ros_package_path:
+                            return False
+                else:
+                    cache[os.path.basename(l)] = l, ros_root, ros_package_path
+        return True
+    except:
+        pass
+    
+def list_pkgs(cache=None, env=None):
+    """
+    List packages in ROS_ROOT and ROS_PACKAGE_PATH.
+
+    If no cache and pkg_dirs arguments are provided, list_pkgs() will
+    use internal _pkg_dir_cache and will return cached answers if
+    available.
+
+    @param cache: Empty dictionary to store package list in.     
+        The format of the cache is {package_name: dir_path, ros_root, ros_package_path}.
+    @type  cache: {str: str, str, str}
+    @return: complete list of package names in ROS environment
+    @rtype: [str]
+    """
+    pkg_dirs = get_package_paths(True, env=env)
+    if cache is None:
+        # if cache is not specified, we use global cache instead
+
+        # TODO: this cache can be out-of-date if rospack has not
+        # been run recently. Figure out correct approach for
+        # out-of-date cache.
+            
+        # TODO: we don't have any logic go populate user-specified
+        # cache in most optimal way
+        cache = _pkg_dir_cache
+        if cache:
+            return list(cache.keys()) #py3k
+        if _update_rospack_cache(env=env):
+            return list(cache.keys()) #py3k
+    packages = []
+    for pkg_root in pkg_dirs:
+        list_pkgs_by_path(pkg_root, packages, cache=cache, env=env)
+    return packages
+
+def list_pkgs_by_path(path, packages=None, cache=None, env=None):
+    """
+    List ROS packages within the specified path.
+
+    Optionally, a cache dictionary can be provided, which will be
+    updated with the package->path mappings. list_pkgs_by_path() does
+    NOT returned cached results -- it only updates the cache.
+    
+    @param path: path to list packages in
+    @type  path: str
+    @param packages: list of packages to append to. If package is
+      already present in packages, it will be ignored.
+    @type  packages: [str]
+    @param cache: (optional) package path cache to update. Maps package name to directory path.
+    @type  cache: {str: str}
+    @return: complete list of package names in ROS environment. Same as packages parameter.
+    @rtype: [str]
+    """
+    if packages is None:
+        packages = []
+    if env is None:
+        env = os.environ
+    # record settings for cache
+    ros_root = env[ROS_ROOT]
+    ros_package_path = env.get(ROS_PACKAGE_PATH, '')
+
+    path = os.path.abspath(path)
+    for d, dirs, files in os.walk(path, topdown=True):
+        if MANIFEST_FILE in files:
+            package = os.path.basename(d)
+            if package not in packages:
+                packages.append(package)
+                if cache is not None:
+                    cache[package] = d, ros_root, ros_package_path
+            del dirs[:]
+            continue #leaf
+        elif 'rospack_nosubdirs' in files:
+            del dirs[:]
+            continue #leaf
+        #small optimization
+        elif '.svn' in dirs:
+            dirs.remove('.svn')
+        elif '.git' in dirs:
+            dirs.remove('.git')
+
+        for sub_d in dirs:
+            # followlinks=True only available in Python 2.6, so we
+            # have to implement manually
+            sub_p = os.path.join(d, sub_d)
+            if os.path.islink(sub_p):
+                packages.extend(list_pkgs_by_path(sub_p, cache=cache))
+            
+    return packages
+
+def find_node(pkg, node_type, ros_root=None, ros_package_path=None):
+    """
+    Locate the executable that implements the node
+    
+    @param node_type: type of node
+    @type  node_type: str
+    @param ros_root: if specified, override ROS_ROOT
+    @type  ros_root: str
+    @param ros_package_path: if specified, override ROS_PACKAGE_PATH
+    @type  ros_package_path: str
+    @return: path to node or None if node is not in the package
+    @rtype: str
+    @raise roslib_electric.packages.InvalidROSPkgException: If package does not exist 
+    """
+
+    if 'ROS_BUILD' in os.environ:
+        tst = os.path.join(os.environ['ROS_BUILD'], 'bin', node_type)
+        if os.path.isfile(tst):
+            return tst
+
+    d = get_pkg_dir(pkg, required=True, \
+                    ros_root=ros_root, ros_package_path=ros_package_path)
+    
+    #UNIXONLY: (partial) slowly supporting Windows here
+    if sys.platform in ['win32', 'cygwin']:
+        # Windows logic requires more file patterns to resolve and is
+        # not case-sensitive, so leave it separate
+
+        # in the near-term, just hack in support for .exe/.bat. In the long
+        # term this needs to:
+        #
+        #  * parse PATHEXT to generate matches
+        #  * perform case-insensitive compares against potential
+        #    matches, in path-ext order
+
+        # - We still have to look for bare node_type as user may have
+        #   specified extension manually
+        node_type = node_type.lower()
+        matches = [node_type, node_type+'.exe', node_type+'.bat']
+        for p, dirs, files in os.walk(d):
+            # case insensitive
+            files = [f.lower() for f in files]
+            for m in matches:
+                if m in files:
+                    test_path = os.path.join(p, m)
+                    s = os.stat(test_path)
+                    if (s.st_mode & (stat.S_IRUSR | stat.S_IXUSR) ==
+                        (stat.S_IRUSR | stat.S_IXUSR)):
+                        return test_path
+            if '.svn' in dirs:
+                dirs.remove('.svn')
+            elif '.git' in dirs:
+                dirs.remove('.git')
+    else:
+        #TODO: this could just execute find_resource with a filter_fn
+        for p, dirs, files in os.walk(d):
+            if node_type in files:
+                test_path = os.path.join(p, node_type)
+                s = os.stat(test_path)
+                if (s.st_mode & (stat.S_IRUSR | stat.S_IXUSR) ==
+                    (stat.S_IRUSR | stat.S_IXUSR)):
+                    return test_path
+            if '.svn' in dirs:
+                dirs.remove('.svn')
+            elif '.git' in dirs:
+                dirs.remove('.git')
+
+def find_resource(pkg, resource_name, filter_fn=None, ros_root=None, ros_package_path=None):
+    """
+    Locate the file named resource_name in package, optionally
+    matching specified filter
+    @param filter: function that takes in a path argument and
+        returns True if the it matches the desired resource
+    @type  filter: fn(str)
+    @param ros_root: if specified, override ROS_ROOT
+    @type  ros_root: str
+    @param ros_package_path: if specified, override ROS_PACKAGE_PATH
+    @type  ros_package_path: str
+    @return: lists of matching paths for resource
+    @rtype: [str]
+    @raise roslib_electric.packages.InvalidROSPkgException: If package does not exist 
+    """
+    d = get_pkg_dir(pkg, required=True, \
+                    ros_root=ros_root, ros_package_path=ros_package_path)
+    #UNIXONLY
+    matches = []
+    node_exe = None
+    for p, dirs, files in os.walk(d):
+        if resource_name in files:
+            test_path = os.path.join(p, resource_name)
+            if filter_fn is not None:
+                if filter_fn(test_path):
+                    matches.append(test_path)
+            else:
+                matches.append(test_path)
+        if '.svn' in dirs:
+            dirs.remove('.svn')
+        elif '.git' in dirs:
+            dirs.remove('.git')
+    return matches
+
+def rosdeps_of(packages):
+    """
+    Collect all rosdeps of specified packages into a dictionary.
+    @param packages: package names
+    @type  packages: [str]
+    @return: dictionary mapping package names to list of rosdep names.
+    @rtype: {str: [str]}
+    """
+    if not type(packages) in [list, tuple]:
+        raise TypeError("packages must be list or tuple")
+    _update_rospack_cache()
+    from roslib_electric.manifest import load_manifest
+    manifests = [load_manifest(p) for p in packages]
+    map = {}
+    for pkg, m in zip(packages, manifests): #py3k
+        map[pkg] = [d.name for d in m.rosdeps]
+    return map
+
+def _safe_load_manifest(p):
+    """
+    Calls roslib_electric.manifest.load_manifest and returns None if the calls raises an Exception (i.e. invalid package)
+    """
+    try:
+        return roslib_electric.manifest.load_manifest(p)
+    except:
+        return roslib_electric.manifest.Manifest()
+
+class ROSPackages(object):
+    """
+    UNSTABLE/EXPERIMENTAL
+    
+    Utility class for querying properties about ROS packages. This
+    should be used when querying properties about multiple
+    packages. ROSPackages caches information about packages, which
+    enables it to have higher performance than alternatives like
+    shelling out to rospack.
+
+    Example::
+      rp = ROSPackages()
+      d = rp.depends1(['roscpp', 'rospy'])
+      print d['roscpp']
+      d = rp.rosdeps(['roscpp', 'rospy'])
+      print d['rospy']
+    """
+    
+    def __init__(self):
+        self.manifests = {}
+        self._depends_cache = {}
+        self._rosdeps_cache = {}
+
+    def load_manifests(self, packages):
+        """
+        Load manifests for specified packages into 'manifests' attribute.
+        
+        
+        @param packages: package names
+        @type  packages: [str]
+        """
+
+        if not type(packages) in [list, tuple]:
+            raise TypeError("packages must be list or tuple")
+
+        # load any manifests that we haven't already
+        to_load = [p for p in packages if not p in self.manifests]
+        if to_load:
+            _update_rospack_cache()
+            self.manifests.update(dict([(p, _safe_load_manifest(p)) for p in to_load]))
+        
+    def depends1(self, packages):
+        """
+        Collect all direct dependencies of specified packages into a
+        dictionary.
+        
+        @param packages: package names
+        @type  packages: [str]
+        @return: dictionary mapping package names to list of dependent package names.
+        @rtype: {str: [str]}
+        """
+        self.load_manifests(packages)
+        map = {}
+        manifests = self.manifests
+        for pkg in packages:
+            map[pkg] = [d.package for d in manifests[pkg].depends]
+        return map
+
+    def depends(self, packages):
+        """
+        Collect all dependencies of specified packages into a
+        dictionary.
+        
+        @param packages: package names
+        @type  packages: [str]
+        @return: dictionary mapping package names to list of dependent package names.
+        @rtype: {str: [str]}
+        """
+
+        self.load_manifests(packages)
+        map = {}
+        for pkg in packages:
+            if pkg in self._depends_cache:
+                map[pkg] = self._depends_cache[pkg]
+            else:
+                # this will cache for future reference
+                map[pkg] = self._depends(pkg)
+        return map
+
+    def _depends(self, package):
+        """
+        Compute recursive dependencies of a single package and cache
+        the result in self._depends_cache.
+
+        This is an internal routine. It assumes that
+        load_manifests() has already been invoked for package.
+        
+        @param package: package name
+        @type  package: str
+        @return: list of rosdeps
+        @rtype: [str]
+        """
+
+        if package in self._depends_cache:
+            return self._depends_cache[package]
+
+        # assign key before recursive call to prevent infinite case
+        self._depends_cache[package] = s = set()
+        
+        manifests = self.manifests
+        # take the union of all dependencies
+        pkgs = [p.package for p in manifests[package].depends]
+        self.load_manifests(pkgs)
+        for p in pkgs:
+            s.update(self._depends(p))
+        # add in our own deps
+        s.update(pkgs)
+        # cache the return value as a list
+        s = list(s)
+        self._depends_cache[package] = s
+        return s
+    
+    def rosdeps0(self, packages):
+        """
+        Collect rosdeps of specified packages into a dictionary.
+        @param packages: package names
+        @type  packages: [str]
+        @return: dictionary mapping package names to list of rosdep names.
+        @rtype: {str: [str]}
+        """
+
+        self.load_manifests(packages)
+        map = {}
+        manifests = self.manifests
+        for pkg in packages:
+            map[pkg] = [d.name for d in manifests[pkg].rosdeps]
+        return map
+        
+    def rosdeps(self, packages):
+        """
+        Collect all (recursive) dependencies of specified packages
+        into a dictionary.
+        
+        @param packages: package names
+        @type  packages: [str]
+        @return: dictionary mapping package names to list of dependent package names.
+        @rtype: {str: [str]}
+        """
+
+        self.load_manifests(packages)
+        map = {}
+        for pkg in packages:
+            if pkg in self._rosdeps_cache:
+                map[pkg] = self._rosdeps_cache[pkg]
+            else:
+                # this will cache for future reference
+                map[pkg] = self._rosdeps(pkg)
+        return map
+
+    def _rosdeps(self, package):
+        """
+        Compute recursive rosdeps of a single package and cache the
+        result in self._rosdeps_cache.
+
+        This is an internal routine. It assumes that
+        load_manifests() has already been invoked for package.
+        
+        @param package: package name
+        @type  package: str
+        @return: list of rosdeps
+        @rtype: [str]
+        """
+
+        if package in self._rosdeps_cache:
+            return self._rosdeps_cache[package]
+        # set the key before recursive call to prevent infinite case
+        self._rosdeps_cache[package] = s = set()
+
+        manifests = self.manifests
+        # take the union of all dependencies
+        pkgs = [p.package for p in manifests[package].depends]
+        self.load_manifests(pkgs)
+        for p in pkgs:
+            s.update(self._rosdeps(p))
+        # add in our own deps
+        s.update([d.name for d in manifests[package].rosdeps])
+        # cache the return value as a list
+        s = list(s)
+        self._rosdeps_cache[package] = s
+        return s
+        
+def _platform_supported(file, os, version):
+    m = roslib_electric.manifest.parse_file(file)
+    for p in m.platforms:
+        if os == p.os and version == p.version:
+            return True
+    return False
+
+def platform_supported(pkg, os, version):
+    """
+    Return whether the platform defined by os and version is marked as supported in the package
+    @param pkg The package to test for support
+    @param os The os name to test for support
+    @param version The os version to test for support
+    """
+    return _platform_supported(roslib_electric.manifest.manifest_file(pkg), os, version)
+
+def current_platform_supported(pkg):
+    """
+    Return whether the current running platform is marked as supported in the package
+    @param pkg The package to test for support
+    """
+    os_detector = roslib_electric.os_detect.OSDetect()
+    return platform_supported(pkg, os_detector.get_name(), os_detector.get_version())
+
diff -r cc8bd7a5eafb roslib_electric/src/roslib_electric/params.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/src/roslib_electric/params.py	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,90 @@
+# Software License Agreement (BSD License)
+#
+# Copyright (c) 2008, Willow Garage, Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+#  * Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#  * Redistributions in binary form must reproduce the above
+#    copyright notice, this list of conditions and the following
+#    disclaimer in the documentation and/or other materials provided
+#    with the distribution.
+#  * Neither the name of Willow Garage, Inc. nor the names of its
+#    contributors may be used to endorse or promote products derived
+#    from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+# Revision $Id: params.py 14580 2011-08-05 17:32:59Z kwc $
+# $Author: kwc $
+"""
+Utilities for accessing the Parameter Server
+"""
+
+import sys
+import yaml
+
+try:
+    import xmlrpc.client as xmlrpcclient #Python 3.x
+except ImportError:
+    import xmlrpclib as xmlrpcclient #Python 2.x
+
+import roslib_electric.rosenv
+from roslib_electric.names import REMAP
+
+_param_server = None
+
+def load_command_line_node_params(argv):
+    """
+    Load node param mappings (aka private parameters) encoded in
+    command-line arguments, e.g. _foo:=bar. See also roslib_electric.names.load_mappings.
+    @param argv: command-line arguments
+    @param argv: [str]
+    @return: param->value remappings. 
+    @rtype: {str: val}
+    """    
+    mappings = {}
+    for arg in argv:
+        if REMAP in arg:
+            try:
+                src, dst = [x.strip() for x in arg.split(REMAP)]
+                if src and dst:
+                    if len(src) > 1 and src[0] == '_' and src[1] != '_':
+                        mappings[src[1:]] = yaml.load(dst)
+            except:
+                sys.stderr.write("ERROR: Invalid remapping argument '%s'\n"%arg)
+    return mappings
+
+def get_param(key):
+    """
+    Retrieve parameter value from the Parameter Server. Each call to this
+    routine results in an actual network call to the Parameter Server.
+    Client must be an actual ROS node in order to implement a parameter cache.
+
+    @param key: name of parameter to fetch
+    @type  key: str
+    @raise KeyError: if parameter is not set
+    """
+    global _param_server
+    if _param_server is None:
+        _param_server = xmlrpcclient.ServerProxy(roslib_electric.rosenv.get_master_uri())
+    code, status, value = _param_server.getParam('/roslib', key)
+    if code != 1: #unwrap value with Python semantics
+        raise KeyError(key)
+    return value    
+            
diff -r cc8bd7a5eafb roslib_electric/src/roslib_electric/resources.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/src/roslib_electric/resources.py	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,107 @@
+# Software License Agreement (BSD License)
+#
+# Copyright (c) 2008, Willow Garage, Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+#  * Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#  * Redistributions in binary form must reproduce the above
+#    copyright notice, this list of conditions and the following
+#    disclaimer in the documentation and/or other materials provided
+#    with the distribution.
+#  * Neither the name of Willow Garage, Inc. nor the names of its
+#    contributors may be used to endorse or promote products derived
+#    from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+
+"""
+Library for listing ROS filesystem resources. This is mainly used by
+higher-level libraries like L{roslib_electric.msgs}.
+"""
+
+import os
+import itertools
+
+import roslib_electric.manifest
+import roslib_electric.names
+import roslib_electric.packages
+
+def _get_manifest_by_dir(package_dir):
+    """
+    Helper routine for loading Manifest instances
+    @param package_dir: package directory location
+    @type  package_dir: str
+    @return: manifest for package
+    @rtype: Manifest
+    """
+    f = os.path.join(package_dir, roslib_electric.manifest.MANIFEST_FILE)
+    if f:
+        return roslib_electric.manifest.parse_file(f)
+    else:
+        return None
+
+def list_package_resources_by_dir(package_dir, include_depends, subdir, rfilter=os.path.isfile):
+    """
+    List resources in a package directory within a particular
+    subdirectory. This is useful for listing messages, services, etc...
+    @param package_dir: package directory location
+    @type  package_dir: str
+    @param subdir: name of subdirectory
+    @type  subdir: str
+    @param include_depends: if True, include resources in dependencies as well    
+    @type  include_depends: bool
+    @param rfilter: resource filter function that returns true if filename is the desired resource type
+    @type  rfilter: fn(filename)->bool
+    """
+    package = os.path.basename(package_dir)
+    resources = []
+    dir = roslib_electric.packages._get_pkg_subdir_by_dir(package_dir, subdir, False)
+    if os.path.isdir(dir):
+        resources = [roslib_electric.names.resource_name(package, f, my_pkg=package) \
+                     for f in os.listdir(dir) if rfilter(os.path.join(dir, f))]
+    else:
+        resources = []
+    if include_depends:
+        depends = _get_manifest_by_dir(package_dir).depends
+        dirs = [roslib_electric.packages.get_pkg_subdir(d.package, subdir, False) for d in depends]
+        for (dep, dir_) in zip(depends, dirs): #py3k
+            if not dir_ or not os.path.isdir(dir_):
+                continue
+            resources.extend(\
+                [roslib_electric.names.resource_name(dep.package, f, my_pkg=package) \
+                 for f in os.listdir(dir_) if rfilter(os.path.join(dir_, f))])
+    return resources
+
+def list_package_resources(package, include_depends, subdir, rfilter=os.path.isfile):
+    """
+    List resources in a package within a particular subdirectory. This is useful for listing
+    messages, services, etc...    
+    @param package: package name
+    @type  package: str
+    @param subdir: name of subdirectory
+    @type  subdir: str
+    @param include_depends: if True, include resources in dependencies as well    
+    @type  include_depends: bool
+    @param rfilter: resource filter function that returns true if filename is the desired resource type
+    @type  rfilter: fn(filename)->bool
+    """    
+    package_dir = roslib_electric.packages.get_pkg_dir(package)
+    return list_package_resources_by_dir(package_dir, include_depends, subdir, rfilter)
+
diff -r cc8bd7a5eafb roslib_electric/src/roslib_electric/rosenv.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/src/roslib_electric/rosenv.py	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,291 @@
+# Software License Agreement (BSD License)
+#
+# Copyright (c) 2008, Willow Garage, Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+#  * Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#  * Redistributions in binary form must reproduce the above
+#    copyright notice, this list of conditions and the following
+#    disclaimer in the documentation and/or other materials provided
+#    with the distribution.
+#  * Neither the name of Willow Garage, Inc. nor the names of its
+#    contributors may be used to endorse or promote products derived
+#    from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+# Revision $Id: rosenv.py 14291 2011-07-13 03:24:43Z kwc $
+
+"""
+ROS environment variables as well as routines for determining
+configuration values that have environment overrides
+(e.g. ROS_LOG_DIR, ROS_HOME, ROS_TEST_RESULTS_DIR).
+"""
+
+import os
+import sys
+
+import roslib_electric.exceptions
+
+# Global, usually set in setup
+ROS_ROOT         = "ROS_ROOT"
+ROS_MASTER_URI   = "ROS_MASTER_URI"
+ROS_PACKAGE_PATH = "ROS_PACKAGE_PATH"
+ROS_HOME         = "ROS_HOME"
+
+# Build-related
+ROS_BINDEPS_PATH = "ROS_BINDEPS_PATH"
+ROS_BOOST_ROOT = "ROS_BOOST_ROOT"
+
+# Per session
+## hostname/address to bind XML-RPC services to. 
+ROS_IP           ="ROS_IP"
+ROS_HOSTNAME     ="ROS_HOSTNAME"
+ROS_NAMESPACE    ="ROS_NAMESPACE"
+## directory in which log files are written
+ROS_LOG_DIR      ="ROS_LOG_DIR"
+## directory in which test result files are written
+ROS_TEST_RESULTS_DIR = "ROS_TEST_RESULTS_DIR"
+
+class ROSEnvException(roslib_electric.exceptions.ROSLibException):
+    """Base class of roslib_electric.rosenv errors."""
+    pass
+
+def get_ros_root(required=True, env=None):
+    """
+    @param required: (default True). If True, ROS_ROOT must be set and point to a valid directory.
+    @type  required: bool
+    @param env: override environment dictionary
+    @type  env: dict
+    @raise ROSEnvException: if required is True and ROS_ROOT is not
+    set validly
+    """
+    if env is None:
+        env = os.environ
+    p = None
+    try:
+        if ROS_ROOT not in env:
+            raise ROSEnvException("""
+The %(ROS_ROOT)s environment variable has not been set.
+Please set to the location of your ROS installation
+before continuing.
+"""%globals())
+
+        p = env[ROS_ROOT]
+        #Test:
+        # 1. Is a path
+        # 2. Is a directory
+        if not os.path.exists(p):
+            raise ROSEnvException("""
+The %s environment variable has not been set properly:
+%s does not exist.
+Please update your ROS installation before continuing.
+"""%(ROS_ROOT, p))
+        if not os.path.isdir(p):
+            raise ROSEnvException("""
+The %s environment variable has not been set properly:
+%s is not a directory.
+Please update your ROS installation before continuing.
+"""%(ROS_ROOT, p))
+        return p
+    except Exception as e:
+        if required:
+            raise
+        return p
+
+def get_ros_package_path(required=False, env=None):
+    """
+    @param required: (default False) if True, ROS_PACKAGE_PATH must be
+    set and point to a valid directory.
+    @type  required: bool
+    @raise ROSEnvException: if ROS_PACKAGE_PATH is not set and \a
+    required is True
+    """
+    if env is None:
+        env = os.environ
+    try:
+        return env[ROS_PACKAGE_PATH]
+    except KeyError as e:
+        if required:
+            raise ROSEnvException("%s has not been configured"%ROS_PACKAGE_PATH)
+
+def get_master_uri(required=True, env=None, argv=None):
+    """
+    Get the ROS_MASTER_URI setting from the command-line args or
+    environment, command-line args takes precedence.
+    @param required: if True, enables exception raising
+    @type  required: bool
+    @param env: override environment dictionary
+    @type  env: dict
+    @param argv: override sys.argv
+    @type  argv: [str]
+    @raise ROSEnvException: if ROS_MASTER_URI value is invalidly
+    specified or if required and ROS_MASTER_URI is not set
+    """    
+    if env is None:
+        env = os.environ
+    if argv is None:
+        argv = sys.argv
+    try:
+        for arg in argv:
+            if arg.startswith('__master:='):
+                val = None
+                try:
+                    _, val = arg.split(':=')
+                except:
+                    pass
+                
+                # we ignore required here because there really is no
+                # correct return value as the configuration is bad
+                # rather than unspecified
+                if not val:
+                    raise ROSEnvException("__master remapping argument '%s' improperly specified"%arg)
+                return val
+        return env[ROS_MASTER_URI]
+    except KeyError as e:
+        if required:
+            raise ROSEnvException("%s has not been configured"%ROS_MASTER_URI)
+        
+def resolve_path(p):
+    """
+    @param path: path string
+    @type  path: str
+    Catch-all utility routine for fixing ROS environment variables that
+    are a single path (e.g. ROS_ROOT).  Currently this just expands
+    tildes to home directories, but in the future it may encode other
+    behaviors.
+    """
+    if p and p[0] == '~':
+        return os.path.expanduser(p)
+    return p
+    
+def resolve_paths(paths):
+    """
+    @param paths: path string with OS-defined separator (i.e. ':' for Linux)
+    @type  paths: str
+    Catch-all utility routine for fixing ROS environment variables that
+    are paths (e.g. ROS_PACKAGE_PATH).  Currently this just expands
+    tildes to home directories, but in the future it may encode other
+    behaviors.
+    """
+    splits = [p for p in paths.split(os.pathsep) if p]
+    return os.pathsep.join([resolve_path(p) for p in splits])
+
+
+def get_ros_home(env=None):
+    """
+    Get directory location of '.ros' directory (aka ROS home).
+    possible locations for this. The ROS_LOG_DIR environment variable
+    has priority. If that is not set, then ROS_HOME/log is used. If
+    ROS_HOME is not set, $HOME/.ros/log is used.
+
+    @param env: override os.environ dictionary
+    @type  env: dict
+    @return: path to use use for log file directory
+    @rtype: str
+    """
+    if env is None:
+        env = os.environ
+    if ROS_HOME in env:
+        return env[ROS_HOME]
+    else:
+        #slightly more robust than $HOME
+        return os.path.join(os.path.expanduser('~'), '.ros')
+    
+def get_log_dir(env=None):
+    """
+    Get directory to use for writing log files. There are multiple
+    possible locations for this. The ROS_LOG_DIR environment variable
+    has priority. If that is not set, then ROS_HOME/log is used. If
+    ROS_HOME is not set, $HOME/.ros/log is used.
+
+    @param env: override os.environ dictionary
+    @type  env: dict
+    @return: path to use use for log file directory
+    @rtype: str
+    """
+    if env is None:
+        env = os.environ
+    if ROS_LOG_DIR in env:
+        return env[ROS_LOG_DIR]
+    else:
+        return os.path.join(get_ros_home(env), 'log')
+
+def get_test_results_dir(env=None):
+    """
+    Get directory to use for writing test result files. There are multiple
+    possible locations for this. The ROS_TEST_RESULTS_DIR environment variable
+    has priority. If that is set, ROS_TEST_RESULTS_DIR is returned.
+    If ROS_TEST_RESULTS_DIR is not set, then ROS_HOME/test_results is used. If
+    ROS_HOME is not set, $HOME/.ros/test_results is used.
+
+    @param env: environment dictionary (defaults to os.environ)
+    @type  env: dict
+    @return: path to use use for log file directory
+    @rtype: str
+    """
+    if env is None:
+        env = os.environ
+        
+    if ROS_TEST_RESULTS_DIR in env:
+        return env[ROS_TEST_RESULTS_DIR]
+    else:
+        return os.path.join(get_ros_home(env), 'test_results')
+
+# this is a copy of the roslogging utility. it's been moved here as it is a common
+# routine for programs using accessing ROS directories
+def makedirs_with_parent_perms(p):
+    """
+    Create the directory using the permissions of the nearest
+    (existing) parent directory. This is useful for logging, where a
+    root process sometimes has to log in the user's space.
+    @param p: directory to create
+    @type  p: str
+    """    
+    p = os.path.abspath(p)
+    parent = os.path.dirname(p)
+    # recurse upwards, checking to make sure we haven't reached the
+    # top
+    if not os.path.exists(p) and p and parent != p:
+        makedirs_with_parent_perms(parent)
+        s = os.stat(parent)
+        os.mkdir(p)
+
+        # if perms of new dir don't match, set anew
+        s2 = os.stat(p)
+        if s.st_uid != s2.st_uid or s.st_gid != s2.st_gid:
+            os.chown(p, s.st_uid, s.st_gid)
+        if s.st_mode != s2.st_mode:
+            os.chmod(p, s.st_mode)    
+
+def on_ros_path(p):
+    """
+    Check to see if filesystem path is on paths specified in ROS
+    environment (ROS_ROOT, ROS_PACKAGE_PATH).
+
+    New in ROS 1.2.
+    
+    @param p: path
+    @type  p: str
+    @return: True if p is on the ROS path (ROS_ROOT, ROS_PACKAGE_PATH)
+    """
+    pkg = os.path.realpath(roslib_electric.rosenv.resolve_path(p))
+    paths = [p for p in roslib_electric.packages.get_package_paths()]
+    paths = [os.path.realpath(roslib_electric.rosenv.resolve_path(x)) for x in paths]
+    return bool([x for x in paths if pkg == x or pkg.startswith(x + os.sep)])
diff -r cc8bd7a5eafb roslib_electric/src/roslib_electric/roslogging.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/src/roslib_electric/roslogging.py	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,103 @@
+# Software License Agreement (BSD License)
+#
+# Copyright (c) 2008, Willow Garage, Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+#  * Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#  * Redistributions in binary form must reproduce the above
+#    copyright notice, this list of conditions and the following
+#    disclaimer in the documentation and/or other materials provided
+#    with the distribution.
+#  * Neither the name of Willow Garage, Inc. nor the names of its
+#    contributors may be used to endorse or promote products derived
+#    from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+# Revision $Id: roslogging.py 14773 2011-08-22 17:49:27Z kwc $
+# $Author: kwc $
+
+"""
+Library for configuring python logging to standard ROS locations (e.g. ROS_LOG_DIR).
+"""
+
+import os
+import sys
+import logging
+import logging.config
+
+import roslib_electric.rosenv
+from roslib_electric.rosenv import get_ros_root, ROS_LOG_DIR, ROS_HOME, makedirs_with_parent_perms
+import roslib_electric.exceptions
+
+get_log_dir = roslib_electric.rosenv.get_log_dir
+    
+def configure_logging(logname, level=logging.INFO, filename=None, env=None):
+    """
+    Configure Python logging package to send log files to ROS-specific log directory
+    @param logname str: name of logger
+    @type  logname: str
+    @param filename: filename to log to. If not set, a log filename
+        will be generated using logname
+    @type filename: str
+    @param env: override os.environ dictionary
+    @type  env: dict
+    @return: log file name
+    @rtype: str
+    @raise roslib_electric.exceptions.ROSLibException: if logging cannot be configured as specified
+    """
+    if env is None:
+        env = os.environ
+
+    logname = logname or 'unknown'
+    log_dir = get_log_dir(env=env)
+    
+    # if filename is not explicitly provided, generate one using logname
+    if not filename:
+        log_filename = os.path.join(log_dir, '%s-%s.log'%(logname, os.getpid()))
+    else:
+        log_filename = os.path.join(log_dir, filename)
+
+    logfile_dir = os.path.dirname(log_filename)
+    if not os.path.exists(logfile_dir):
+        try:
+            makedirs_with_parent_perms(logfile_dir)
+        except OSError:
+            # cannot print to screen because command-line tools with output use this
+            sys.stderr.write("WARNING: cannot create log directory [%s]. Please set %s to a writable location.\n"%(logfile_dir, ROS_LOG_DIR))
+            return None
+    elif os.path.isfile(logfile_dir):
+        raise roslib_electric.exceptions.ROSLibException("Cannot save log files: file [%s] is in the way"%logfile_dir)
+
+    if 'ROS_PYTHON_LOG_CONFIG_FILE' in os.environ:
+        config_file = os.environ['ROS_PYTHON_LOG_CONFIG_FILE']
+    else:
+        config_file = os.path.join(get_ros_root(env=env), 'config', 'python_logging.conf')
+
+    if not os.path.isfile(config_file):
+        # logging is considered soft-fail
+        sys.stderr.write("WARNING: cannot load logging configuration file, logging is disabled\n")
+        return log_filename
+    
+    # pass in log_filename as argument to pylogging.conf
+    os.environ['ROS_LOG_FILENAME'] = log_filename
+    # #3625: disabling_existing_loggers=False
+    logging.config.fileConfig(config_file, disable_existing_loggers=False)
+    return log_filename
+
diff -r cc8bd7a5eafb roslib_electric/src/roslib_electric/rospack.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/src/roslib_electric/rospack.py	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,172 @@
+# Software License Agreement (BSD License)
+#
+# Copyright (c) 2008, Willow Garage, Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+#  * Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#  * Redistributions in binary form must reproduce the above
+#    copyright notice, this list of conditions and the following
+#    disclaimer in the documentation and/or other materials provided
+#    with the distribution.
+#  * Neither the name of Willow Garage, Inc. nor the names of its
+#    contributors may be used to endorse or promote products derived
+#    from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+# Revision $Id: rospack.py 16493 2012-03-08 19:25:32Z kwc $
+# $Author: kwc $
+
+"""
+Wrappers for calling an processing return values from rospack and rosstack
+"""
+
+import os
+import sys
+import subprocess
+import roslib_electric.exceptions
+import roslib_electric.rosenv
+
+if sys.hexversion > 0x03000000: #Python3
+    python3 = True
+else:
+    python3 = False
+
+import threading
+
+rospack_lock = threading.Lock()
+
+def rospackexec(args):
+    """
+    @return: result of executing rospack command (via subprocess). string will be strip()ed.
+    @rtype: str
+    @raise roslib_electric.exceptions.ROSLibException: if rospack command fails
+    """
+    rospack_bin = os.path.join(roslib_electric.rosenv.get_ros_root(), 'bin', 'rospack')
+    with rospack_lock:
+        if python3:
+            val = subprocess.Popen([rospack_bin] + args, stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()[0]
+            val = val.decode().strip()
+        else:
+            val = (subprocess.Popen([rospack_bin] + args, stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()[0] or '').strip()        
+    if val.startswith('rospack:'): #rospack error message
+        raise roslib_electric.exceptions.ROSLibException(val)
+    return val
+
+def rospack_depends_on_1(pkg):
+    """
+    @param pkg: package name
+    @type  pkg: str
+    @return: A list of the names of the packages which depend directly on pkg
+    @rtype: list
+    """
+    return rospackexec(['depends-on1', pkg]).split()
+
+def rospack_depends_on(pkg):
+    """
+    @param pkg: package name
+    @type  pkg: str
+    @return: A list of the names of the packages which depend on pkg
+    @rtype: list
+    """
+    return rospackexec(['depends-on', pkg]).split()
+
+def rospack_depends_1(pkg):
+    """
+    @param pkg: package name
+    @type  pkg: str
+    @return: A list of the names of the packages which pkg directly depends on
+    @rtype: list    
+    """
+    return rospackexec(['deps1', pkg]).split()
+
+def rospack_depends(pkg):
+    """
+    @param pkg: package name
+    @type  pkg: str
+    @return: A list of the names of the packages which pkg depends on
+    @rtype: list    
+    """
+    return rospackexec(['deps', pkg]).split()
+
+def rospack_plugins(pkg):
+    """
+    @param pkg: package name
+    @type  pkg: str
+    @return: A list of the names of the packages which provide a plugin for pkg
+    @rtype: list    
+    """
+    val = rospackexec(['plugins', '--attrib=plugin', pkg])
+    if val:
+      return [tuple(x.split(' ')) for x in val.split('\n')]
+    else:
+      return []
+
+def rosstackexec(args):
+    """
+    @return: result of executing rosstack command (via subprocess). string will be strip()ed.
+    @rtype:  str
+    @raise roslib_electric.exceptions.ROSLibException: if rosstack command fails
+    """
+    rosstack_bin = os.path.join(roslib_electric.rosenv.get_ros_root(), 'bin', 'rosstack')
+    with rospack_lock:
+        if python3:
+            val = subprocess.Popen([rosstack_bin] + args, stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()[0]
+            val = val.decode().strip()
+        else:
+            val = (subprocess.Popen([rosstack_bin] + args, stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()[0] or '').strip()
+        if val.startswith('rosstack:'): #rospack error message
+            raise roslib_electric.exceptions.ROSLibException(val)
+    return val
+
+def rosstack_depends_on(s):
+    """
+    @param s: stack name
+    @type  s: str
+    @return: A list of the names of the stacks which depend on s
+    @rtype: list
+    """
+    return rosstackexec(['depends-on', s]).split()
+
+def rosstack_depends_on_1(s):
+    """
+    @param s: stack name
+    @type  s: str
+    @return: A list of the names of the stacks which depend directly on s
+    @rtype: list
+    """
+    return rosstackexec(['depends-on1', s]).split()
+
+def rosstack_depends(s):
+    """
+    @param s: stack name
+    @type  s: str
+    @return: A list of the names of the stacks which s depends on 
+    @rtype: list
+    """
+    return rosstackexec(['depends', s]).split()
+
+def rosstack_depends_1(s):
+    """
+    @param s: stack name
+    @type  s: str
+    @return: A list of the names of the stacks which s depends on directly
+    @rtype: list
+    """
+    return rosstackexec(['depends1', s]).split()
diff -r cc8bd7a5eafb roslib_electric/src/roslib_electric/rostime.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/src/roslib_electric/rostime.py	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,465 @@
+# Software License Agreement (BSD License)
+#
+# Copyright (c) 2008, Willow Garage, Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+#  * Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#  * Redistributions in binary form must reproduce the above
+#    copyright notice, this list of conditions and the following
+#    disclaimer in the documentation and/or other materials provided
+#    with the distribution.
+#  * Neither the name of Willow Garage, Inc. nor the names of its
+#    contributors may be used to endorse or promote products derived
+#    from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+# Revision $Id: rostime.py 14969 2011-09-12 20:09:18Z kwc $
+
+"""
+ROS Time representation, including Duration
+"""
+
+import itertools
+import time
+import sys
+
+if sys.version > '3':
+	long = int
+
+def _canon(secs, nsecs):
+    #canonical form: nsecs is always positive, nsecs < 1 second
+    while nsecs >= 1000000000:
+        secs += 1
+        nsecs -= 1000000000
+    while nsecs < 0:
+        secs -= 1
+        nsecs += 1000000000
+    return secs,nsecs
+
+class TVal(object):
+    """
+    Base class of L{Time} and L{Duration} representations. Representation
+    is secs+nanoseconds since epoch.
+    """
+
+    __slots__ = ['secs', 'nsecs']
+    def __init__(self, secs=0, nsecs=0):
+        """
+        @param secs: seconds. If secs is a float, then nsecs must not be set or 0
+        @type  secs: int/float
+        @param nsecs: nanoseconds
+        @type  nsecs: int
+        """
+        if type(secs) != int:
+            # float secs constructor
+            if nsecs != 0:
+                raise ValueError("if secs is a float, nsecs cannot be set")
+            float_secs = secs
+            secs = int(float_secs)
+            nsecs = int((float_secs - secs) * 1000000000)
+
+        self.secs, self.nsecs = _canon(secs, nsecs)
+
+    def is_zero(self):
+        """
+        @return: True if time is zero (secs and nsecs are zero)
+        @rtype: bool
+        """
+        return self.secs == 0 and self.nsecs == 0
+    
+    def set(self, secs, nsecs):
+        """
+        Set time using separate secs and nsecs values
+        
+        @param secs: seconds since epoch
+        @type  secs: int
+        @param nsecs: nanoseconds since seconds
+        @type  nsecs: int
+        """
+        self.secs = secs
+        self.nsecs = nsecs
+
+    def canon(self):
+        """
+        Canonicalize the field representation in this instance.  should
+        only be used when manually setting secs/nsecs slot values, as
+        in deserialization.
+        """
+        self.secs, self.nsecs = _canon(self.secs, self.nsecs)
+        
+    def to_sec(self):
+        """
+        @return: time as float seconds (same as time.time() representation)
+        @rtype: float
+        """
+        return float(self.secs) + float(self.nsecs) / 1e9
+
+    def to_nsec(self):
+        """
+        @return: time as nanoseconds
+        @rtype: long
+        """
+        return self.secs * long(1e9) + self.nsecs
+        
+    def __hash__(self):
+        """
+        Time values are hashable. Time values with identical fields have the same hash.
+        """
+        return ("%s.%s"%(self.secs, self.nsecs)) .__hash__()
+
+    def __str__(self):
+        return str(self.to_nsec())
+
+    def __repr__(self):
+        return "rostime.TVal[%d]"%self.to_nsec()
+
+    def __nonzero__(self):
+        """
+        Check if time value is zero
+        """
+        return self.secs or self.nsecs
+
+    def __lt__(self, other):
+        """
+        < test for time values
+        """
+        try:
+            return self.__cmp__(other) < 0
+        except TypeError:
+            return NotImplemented
+    def __le__(self, other):
+        """
+        <= test for time values
+        """
+        try:
+            return self.__cmp__(other) <= 0
+        except TypeError:
+            return NotImplemented
+    def __gt__(self, other):
+        """
+        > test for time values
+        """
+        try:
+            return self.__cmp__(other) > 0
+        except TypeError:
+            return NotImplemented
+    def __ge__(self, other):
+        """
+        >= test for time values
+        """
+        try:
+            return self.__cmp__(other) >= 0
+        except TypeError:
+            return NotImplemented
+    def __ne__(self, other):
+        return not self.__eq__(other)
+    def __cmp__(self, other):
+        if not isinstance(other, TVal):
+            raise TypeError("Cannot compare to non-TVal")
+        nanos = self.to_nsec() - other.to_nsec()
+        if nanos > 0:
+            return 1
+        if nanos == 0:
+            return 0
+        return -1
+    def __eq__(self, other):
+        if not isinstance(other, TVal):
+            return False
+        return self.to_nsec() == other.to_nsec()
+
+class Time(TVal):
+    """
+    Time contains the ROS-wide 'time' primitive representation, which
+    consists of two integers: seconds since epoch and nanoseconds since
+    seconds. Time instances are mutable.
+    """
+    __slots__ = ['secs', 'nsecs']
+    def __init__(self, secs=0, nsecs=0):
+        """
+        Constructor: secs and nsecs are integers. You may prefer to use the static L{from_sec()} factory
+        method instead.
+        
+        @param secs: seconds since epoch
+        @type  secs: int
+        @param nsecs: nanoseconds since seconds (since epoch)
+        @type  nsecs: int
+        """
+        super(Time, self).__init__(secs, nsecs)
+        if self.secs < 0:
+            raise TypeError("time values must be positive")
+
+    def __getstate__(self):
+        """
+        support for Python pickling
+        """
+        return [self.secs, self.nsecs]
+
+    def __setstate__(self, state):
+        """
+        support for Python pickling
+        """
+        self.secs, self.nsecs = state
+
+    def from_sec(float_secs):
+        """
+        Create new Time instance using time.time() value (float
+        seconds)
+        
+        @param float_secs: time value in time.time() format
+        @type  float_secs: float
+        @return: Time instance for specified time
+        @rtype: L{Time}
+        """
+        secs = int(float_secs)
+        nsecs = int((float_secs - secs) * 1000000000)
+        return Time(secs, nsecs)
+    
+    from_sec = staticmethod(from_sec)    
+
+    def to_time(self):
+        """
+        Get Time in time.time() format. alias of L{to_sec()}
+        
+        @return: time in floating point secs (time.time() format)
+        @rtype: float
+        """
+        return self.to_sec()
+
+    def __repr__(self):
+        return "rostime.Time[%d]"%self.to_nsec()
+
+    def __add__(self, other):
+        """
+        Add duration to this time
+        
+        @param other: duration
+        @type  other: L{Duration}
+        """
+        if not isinstance(other, Duration):
+            return NotImplemented
+        return Time(self.secs + other.secs, self.nsecs + other.nsecs)
+
+    def __sub__(self, other):
+        """
+        Subtract time or duration from this time
+        @param other: duration
+        @type  other: L{Duration}/L{Time}
+        @return: L{Duration} if other is a L{Time}, L{Time} if other is a L{Duration}
+        """
+        if isinstance(other, Time):
+            return Duration(self.secs - other.secs, self.nsecs - other.nsecs)
+        elif isinstance(other, Duration):
+            return Time(self.secs - other.secs, self.nsecs - other.nsecs)
+        else:
+            return NotImplemented
+
+    def __cmp__(self, other):
+        """
+        Compare to another time
+        @param other: Time
+        @type  other: L{Time}
+        """
+        if not isinstance(other, Time):
+            raise TypeError("cannot compare to non-Time")
+        nanos = self.to_nsec() - other.to_nsec()
+        if nanos > 0:
+            return 1
+        if nanos == 0:
+            return 0
+        return -1
+
+    def __eq__(self, other):
+        """
+        Equals test for Time. Comparison assumes that both time
+        instances are in canonical representation; only compares fields.
+        
+        @param other: Time
+        @type  other: L{Time}
+        """
+        if not isinstance(other, Time):
+            return False
+        return self.secs == other.secs and self.nsecs == other.nsecs
+
+class Duration(TVal):
+    """
+    Duration represents the ROS 'duration' primitive, which consists
+    of two integers: seconds and nanoseconds. The Duration class
+    allows you to add and subtract Duration instances, including
+    adding and subtracting from L{Time} instances.
+    """
+    __slots__ = ['secs', 'nsecs']
+    def __init__(self, secs=0, nsecs=0):
+        """
+        Create new Duration instance. secs and nsecs are integers and correspond to the ROS 'duration' primitive.
+
+        @param secs: seconds
+        @type  secs: int
+        @param nsecs: nanoseconds
+        @type  nsecs: int
+        """
+        super(Duration, self).__init__(secs, nsecs)
+
+    def __getstate__(self):
+        """
+        support for Python pickling
+        """
+        return [self.secs, self.nsecs]
+
+    def __setstate__(self, state):
+        """
+        support for Python pickling
+        """
+        self.secs, self.nsecs = state
+
+    def __repr__(self):
+        return "rostime.Duration[%d]"%self.to_nsec()
+
+    def from_sec(float_seconds):
+        """
+        Create new Duration instance from float seconds format.
+        
+        @param float_seconds: time value in specified as float seconds
+        @type  float_seconds: float
+        @return: Duration instance for specified float_seconds
+        @rtype: Duration
+        """
+        secs = int(float_seconds)
+        nsecs = int((float_seconds - secs) * 1000000000)
+        return Duration(secs, nsecs)
+    
+    from_sec = staticmethod(from_sec)    
+
+    def __neg__(self):
+        """
+        @return: Negative value of this duration
+        @rtype:  L{Duration}
+        """
+        return Duration(-self.secs, -self.nsecs)
+    def __abs__(self):
+        """
+        Absolute value of this duration
+        @return: positive duration
+        @rtype:  L{Duration}
+        """
+        if self.secs > 0:
+            return self
+        return self.__neg__()
+
+    def __add__(self, other):
+        """
+        Add duration to this duration, or this duration to a time, creating a new time value as a result.
+        @param other: duration or time
+        @type  other: L{Duration}/L{Time}
+        @return: L{Duration} if other is a L{Duration}, L{Time} if other is a L{Time}
+        """
+        if isinstance(other, Time):
+            return other.__add__(self)
+        elif isinstance(other, Duration):
+            return Duration(self.secs+other.secs, self.nsecs+other.nsecs)
+        else:
+            return NotImplemented
+    def __sub__(self, other):
+        """
+        Subtract duration from this duration, returning a new duration
+        @param other: duration
+        @type  other: L{Duration}
+        @return: L{Duration} 
+        """
+        if not isinstance(other, Duration):
+            return NotImplemented
+        return Duration(self.secs-other.secs, self.nsecs-other.nsecs)        
+
+    def __mul__(self, val):
+        """
+        Multiply this duration by an integer or float
+        @param val: multiplication factor
+        @type  val: int/float
+        @return: Duration multiplied by val
+        @rtype:  L{Duration}
+        """
+        t = type(val)
+        if t in (int, long):
+            return Duration(self.secs * val, self.nsecs * val)
+        elif t == float:
+            return Duration.from_sec(self.to_sec() * val)
+        else:
+            return NotImplemented
+
+    def __floordiv__(self, val):
+        """
+        Floor divide this duration by an integer or float
+        @param val: division factor
+        @type  val: int/float
+        @return: Duration multiplied by val
+        @rtype:  L{Duration}
+        """
+        t = type(val)
+        if t in (int, long):
+            return Duration(self.secs // val, self.nsecs // val)
+        elif t == float:
+            return Duration.from_sec(self.to_sec() // val)
+        else:
+            return NotImplemented
+
+    def __div__(self, val):
+        """
+        Divide this duration by an integer or float
+        @param val: division factor
+        @type  val: int/float
+        @return: Duration multiplied by val
+        @rtype:  L{Duration}
+        """
+        # unlike __floordiv__, this uses true div for float arg.
+        # PEP 238
+        t = type(val)
+        if t in (int, long):
+            return Duration(self.secs // val, self.nsecs // val)
+        elif t == float:
+            return Duration.from_sec(self.to_sec() / val)
+        else:
+            return NotImplemented
+
+    def __truediv__(self, val):
+        """
+        Divide this duration by an integer or float
+        @param val: division factor
+        @type  val: int/float
+        @return: Duration multiplied by val
+        @rtype:  L{Duration}
+        """
+        if type(val) in (int, long, float):
+            return Duration.from_sec(self.to_sec() / val)
+        else:
+            return NotImplemented
+
+    def __cmp__(self, other):
+        if not isinstance(other, Duration):
+            raise TypeError("Cannot compare to non-Duration")
+        nanos = self.to_nsec() - other.to_nsec()
+        if nanos > 0:
+            return 1
+        if nanos == 0:
+            return 0
+        return -1
+
+    def __eq__(self, other):
+        if not isinstance(other, Duration):
+            return False
+        return self.secs == other.secs and self.nsecs == other.nsecs
diff -r cc8bd7a5eafb roslib_electric/src/roslib_electric/scriptutil.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/src/roslib_electric/scriptutil.py	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,213 @@
+# Software License Agreement (BSD License)
+#
+# Copyright (c) 2008, Willow Garage, Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+#  * Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#  * Redistributions in binary form must reproduce the above
+#    copyright notice, this list of conditions and the following
+#    disclaimer in the documentation and/or other materials provided
+#    with the distribution.
+#  * Neither the name of Willow Garage, Inc. nor the names of its
+#    contributors may be used to endorse or promote products derived
+#    from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+# Revision $Id: scriptutil.py 14631 2011-08-10 03:37:14Z kwc $
+# $Author: kwc $
+
+"""
+Common ros script utilities, such as methods convenience methods for
+creating master xmlrpc proxies and executing rospack. This library
+is relatively immature and much of the functionality here will
+likely be moved elsewhere as the API solidifies.
+"""
+
+import itertools
+import os
+import re
+import string
+import subprocess
+import sys
+
+import roslib_electric.exceptions
+import roslib_electric.launcher
+import roslib_electric.message
+import roslib_electric.msgs 
+import roslib_electric.names 
+import roslib_electric.network
+import roslib_electric.packages
+import roslib_electric.rosenv 
+
+PRODUCT = 'ros'
+
+## caller ID for master calls where caller ID is not vital
+_GLOBAL_CALLER_ID = '/script'
+
+_is_interactive = False
+def set_interactive(interactive):
+    """
+    General API for a script specifying that it is being run in an
+    interactive environment. Many libraries may wish to change their
+    behavior based on being interactive (e.g. disabling signal
+    handlers on Ctrl-C).
+
+    @param interactive: True if current script is being run in an interactive shell
+    @type  interactive: bool
+    """
+    global _is_interactive
+    _is_interactive = interactive
+
+def is_interactive():
+    """
+    General API for a script specifying that it is being run in an
+    interactive environment. Many libraries may wish to change their
+    behavior based on being interactive (e.g. disabling signal
+    handlers on Ctrl-C).
+
+    @return: True if interactive flag has been set
+    @rtype: bool
+    """
+    return _is_interactive
+
+def myargv(argv=None):
+    """
+    Remove ROS remapping arguments from sys.argv arguments.
+    @return: copy of sys.argv with ROS remapping arguments removed
+    @rtype: [str]
+    """
+    if argv is None:
+        argv = sys.argv
+    return [a for a in argv if not roslib_electric.names.REMAP in a]
+
+def script_resolve_name(script_name, name):
+    """
+    Name resolver for scripts. Supports ROS_NAMESPACE.  Does not
+    support remapping arguments.
+    @param name: name to resolve
+    @type  name: str
+    @param script_name: name of script. script_name must not
+    contain a namespace.
+    @type  script_name: str
+    @return: resolved name
+    @rtype: str
+    """
+    if not name: #empty string resolves to namespace
+        return roslib_electric.names.get_ros_namespace()
+    #Check for global name: /foo/name resolves to /foo/name
+    if roslib_electric.names.is_global(name):
+        return name
+    #Check for private name: ~name resolves to /caller_id/name
+    elif roslib_electric.names.is_private(name):
+        return ns_join(roslib_electric.names.make_caller_id(script_name), name[1:])
+    return roslib_electric.names.get_ros_namespace() + name
+
+def get_master():
+    """
+    Get an XMLRPC handle to the Master. It is recommended to use the
+    `rosgraph.masterapi` library instead, as it provides many
+    conveniences.
+    
+    @return: XML-RPC proxy to ROS master
+    @rtype: xmlrpclib.ServerProxy
+    """
+    try:
+        import xmlrpc.client as xmlrpcclient  #Python 3.x
+    except ImportError:
+        import xmlrpclib as xmlrpcclient #Python 2.x
+    
+    # #1730 validate URL for better error messages
+    uri = roslib_electric.rosenv.get_master_uri()
+    try:
+        roslib_electric.network.parse_http_host_and_port(uri)
+    except ValueError:
+        raise roslib_electric.exceptions.ROSLibException("invalid master URI: %s"%uri)
+    return xmlrpcclient.ServerProxy(uri)
+
+
+def get_param_server():
+    """
+    @return: ServerProxy XML-RPC proxy to ROS parameter server
+    @rtype: xmlrpclib.ServerProxy
+    """
+    return get_master()
+
+def is_subscriber(topic, subscriber_id):
+    """
+    Check whether or not master think subscriber_id subscribes to topic
+    @return: True if still register as a subscriber
+    @rtype: bool
+    @raise roslib_electric.exceptions.ROSLibException: if communication with master fails
+    """
+    m = get_master()
+    code, msg, state = m.getSystemState(_GLOBAL_CALLER_ID)
+    if code != 1:
+        raise roslib_electric.exceptions.ROSLibException("Unable to retrieve master state: %s"%msg)
+    _, subscribers, _ = state
+    for t, l in subscribers:
+        if t == topic:
+            return subscriber_id in l
+    else:
+        return False
+
+def is_publisher(topic, publisher_id):
+    """
+    Predicate to check whether or not master think publisher_id
+    publishes topic
+    @return: True if still register as a publisher
+    @rtype: bool
+    @raise roslib_electric.exceptions.ROSLibException: if communication with master fails
+    """
+    m = get_master()
+    code, msg, state = m.getSystemState(_GLOBAL_CALLER_ID)
+    if code != 1:
+        raise roslib_electric.exceptions.ROSLibException("Unable to retrieve master state: %s"%msg)
+    pubs, _, _ = state
+    for t, l in pubs:
+        if t == topic:
+            return publisher_id in l
+    else:
+        return False
+
+def ask_and_call(cmds, cwd=None):
+    """
+    Pretty print cmds, ask if they should be run, and if so, runs
+    them using subprocess.check_call.
+
+    @param cwd: (optional) set cwd of command that is executed
+    @type  cwd: str
+    @return: True if cmds were run.
+    """
+    # Pretty-print a string version of the commands
+    def quote(s):
+        return '"%s"'%s if ' ' in s else s
+    sys.stdout.write("Okay to execute:\n\n%s\n(y/n)?\n"%('\n'.join([' '.join([quote(s) for s in c]) for c in cmds])))
+    while 1:
+        input = sys.stdin.readline().strip().lower()
+        if input in ['y', 'n']:
+            break
+    accepted = input == 'y'
+    if accepted:
+        for c in cmds:
+            if cwd:
+                subprocess.check_call(c, cwd=cwd)
+            else:
+                subprocess.check_call(c)                
+    return accepted
diff -r cc8bd7a5eafb roslib_electric/src/roslib_electric/srvs.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/src/roslib_electric/srvs.py	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,226 @@
+# Software License Agreement (BSD License)
+#
+# Copyright (c) 2008, Willow Garage, Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+#  * Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#  * Redistributions in binary form must reproduce the above
+#    copyright notice, this list of conditions and the following
+#    disclaimer in the documentation and/or other materials provided
+#    with the distribution.
+#  * Neither the name of Willow Garage, Inc. nor the names of its
+#    contributors may be used to endorse or promote products derived
+#    from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+# Revision $Id: srvs.py 14234 2011-07-12 00:19:01Z kwc $
+# $Author: kwc $
+"""
+ROS Service Description Language Spec
+Implements U{http://ros.org/wiki/srv}
+"""
+
+import os
+import sys
+import re
+
+try:
+    from cStringIO import StringIO # Python 2.x
+except ImportError:
+    from io import StringIO # Python 3.x
+
+import roslib_electric.exceptions
+import roslib_electric.msgs
+import roslib_electric.names
+import roslib_electric.packages
+import roslib_electric.resources
+
+# don't directly use code from this, though we do depend on the
+# manifest.Depend data type
+import roslib_electric.manifest
+
+## file extension
+EXT = roslib_electric.names.SRV_EXT #alias
+SEP = roslib_electric.names.PRN_SEPARATOR #e.g. std_msgs/String
+## input/output deliminator
+IODELIM   = '---'
+COMMENTCHAR = roslib_electric.msgs.COMMENTCHAR
+
+VERBOSE = False
+## @return: True if msg-related scripts should print verbose output
+def is_verbose():
+    return VERBOSE
+
+## set whether msg-related scripts should print verbose output
+def set_verbose(v):
+    global VERBOSE
+    VERBOSE = v
+
+class SrvSpecException(roslib_electric.exceptions.ROSLibException): pass
+
+# msg spec representation ##########################################
+
+class SrvSpec(object):
+    
+    def __init__(self, request, response, text, full_name = '', short_name = '', package = ''):
+        self.request = request
+        self.response = response
+        self.text = text
+        self.full_name = full_name
+        self.short_name = short_name
+        self.package = package
+        
+    def __eq__(self, other):
+        if not other or not isinstance(other, SrvSpec):
+            return False
+        return self.request == other.request and \
+               self.response == other.response and \
+               self.text == other.text and \
+               self.full_name == other.full_name and \
+               self.short_name == other.short_name and \
+               self.package == other.package
+    
+    def __ne__(self, other):
+        if not other or not isinstance(other, SrvSpec):
+            return True
+        return not self.__eq__(other)
+
+    def __repr__(self):
+        return "SrvSpec[%s, %s]"%(repr(self.request), repr(self.response))
+    
+# srv spec loading utilities ##########################################
+
+## @internal
+## predicate for filtering directory list. matches message files
+def _srv_filter(f):
+    return os.path.isfile(f) and f.endswith(EXT)
+
+# also used by doxymaker
+def list_srv_types(package, include_depends):
+    """
+    list all services in the specified package
+    @param package: name of package to search
+    @type  package: str
+    @param include_depends: if True, will also list services in package dependencies
+    @type  include_depends: bool
+    @return: service type names
+    @rtype: [str]
+    """
+    types = roslib_electric.resources.list_package_resources(package, include_depends, roslib_electric.packages.SRV_DIR, _srv_filter)
+    return [x[:-len(EXT)] for x in types]
+
+def srv_file(package, type_):
+    """
+    @param package: name of package .srv file is in
+    @type  package: str
+    @param type_: type name of service
+    @type  type_: str
+    @return: file path of .srv file in specified package
+    @rtype: str
+    """
+    return roslib_electric.packages.resource_file(package, roslib_electric.packages.SRV_DIR, type_+EXT)
+
+def get_pkg_srv_specs(package):
+    """
+    List all messages that a package contains
+    @param depend: roslib_electric.manifest.Depend object representing package
+    to load messages from
+    @type  depend: Depend
+    @return: list of message type names and specs for package, as well as a list
+    of message names that could not be processed. 
+    @rtype: [(str,roslib_electric.MsgSpec), [str]]
+    """
+    #almost identical to roslib_electric.msgs.get_pkg_msg_specs
+    types = list_srv_types(package, False)
+    specs = [] #no fancy list comprehension as we want to show errors
+    failures = []
+    for t in types:
+        try: 
+            spec = load_from_file(srv_file(package, t), package)
+            specs.append(spec)
+        except Exception as e:
+            failures.append(t)
+            sys.stderr.write("ERROR: unable to load %s\n"%(t))
+    return specs, failures
+
+def load_from_string(text, package_context='', full_name='', short_name=''):
+    """
+    @param text: .msg text 
+    @type  text: str
+    @param package_context: context to use for msgTypeName, i.e. the package name,
+    or '' to use local naming convention.
+    @type  package_context: str
+    @return: Message type name and message specification
+    @rtype: roslib_electric.MsgSpec
+    @raise roslib_electric.MsgSpecException: if syntax errors or other problems are detected in file
+    """
+    text_in  = StringIO()
+    text_out = StringIO()
+    accum = text_in
+    for l in text.split('\n'):
+        l = l.split(COMMENTCHAR)[0].strip() #strip comments        
+        if l.startswith(IODELIM): #lenient, by request
+            accum = text_out
+        else:
+            accum.write(l+'\n')
+    # create separate roslib_electric.msgs objects for each half of file
+    
+    msg_in = roslib_electric.msgs.load_from_string(text_in.getvalue(), package_context, '%sRequest'%(full_name), '%sRequest'%(short_name))
+    msg_out = roslib_electric.msgs.load_from_string(text_out.getvalue(), package_context, '%sResponse'%(full_name), '%sResponse'%(short_name))
+    return SrvSpec(msg_in, msg_out, text, full_name, short_name, package_context)
+
+def load_from_file(file_name, package_context=''):
+    """
+    Convert the .srv representation in the file to a SrvSpec instance.
+    @param file_name: name of file to load from
+    @type  file_name: str
+    @param package_context: context to use for type name, i.e. the package name,
+    or '' to use local naming convention.
+    @type package_context: str
+    @return: Message type name and message specification
+    @rtype: (str, L{SrvSpec})
+    @raise SrvSpecException: if syntax errors or other problems are detected in file
+    """
+    if VERBOSE:
+        if package_context:
+            sys.stdout.write("Load spec from %s into namespace [%s]\n"%(file_name, package_context))
+        else:
+            sys.stdout.write("Load spec from %s\n"%(file_name))
+    base_file_name = os.path.basename(file_name)
+    type_ = base_file_name[:-len(EXT)]
+    base_type_ = type_
+    # determine the type name
+    if package_context:
+        while package_context.endswith(SEP):
+            package_context = package_context[:-1] #strip message separators
+        type_ = "%s%s%s"%(package_context, SEP, type_)
+    if not roslib_electric.names.is_legal_resource_name(type_):
+        raise SrvSpecException("%s: %s is not a legal service type name"%(file_name, type_))
+    
+    f = open(file_name, 'r')
+    try:
+        text = f.read()
+        return (type_, load_from_string(text, package_context, type_, base_type_))
+    finally:
+        f.close()
+
+
+
+
diff -r cc8bd7a5eafb roslib_electric/src/roslib_electric/stack_manifest.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/src/roslib_electric/stack_manifest.py	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,122 @@
+#! /usr/bin/env python
+# Software License Agreement (BSD License)
+#
+# Copyright (c) 2008, Willow Garage, Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+#  * Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#  * Redistributions in binary form must reproduce the above
+#    copyright notice, this list of conditions and the following
+#    disclaimer in the documentation and/or other materials provided
+#    with the distribution.
+#  * Neither the name of Willow Garage, Inc. nor the names of its
+#    contributors may be used to endorse or promote products derived
+#    from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+# Revision $Id: stack_manifest.py 14230 2011-07-11 23:35:00Z kwc $
+# $Author: kwc $
+
+"""
+Python parser for rospack stack.xml files. See U{http://pr.willowgarage.com/wiki/Stack%20Manifest}
+"""
+
+import sys
+import os
+import getopt
+
+import roslib_electric.exceptions
+import roslib_electric.packages
+import roslib_electric.rosenv
+
+STACK_FILE = 'stack.xml'
+
+import roslib_electric.manifestlib
+# re-export symbols so that external code does not have to import manifestlib as well
+from roslib_electric.manifestlib import ManifestException, StackDepend
+
+class StackManifest(roslib_electric.manifestlib._Manifest):
+    """
+    Object representation of a ROS manifest file
+    """
+    __slots__ = []
+    def __init__(self):
+        """
+        Create an empty stack manifest instance.
+        """
+        super(StackManifest, self).__init__('stack')
+        
+def _stack_file_by_dir(stack_dir, required=True):
+    """
+    @param stack_dir: path to stack directory
+    @type  stack_dir: str
+    @param required: require that the directory exist
+    @type  required: bool
+    @return: path to manifest file of stack
+    @rtype: str
+    @raise InvalidROSPkgException: if required is True and manifest file cannot be located
+    """
+    try:
+        p = os.path.join(stack_dir, STACK_FILE)
+        if not required and not os.path.exists(p):
+            return p
+        if not os.path.isfile(p):
+            raise roslib_electric.stacks.InvalidROSStackException("""
+Stack '%(stack_dir)s' is improperly configured: no manifest file is present.
+"""%locals())
+        return p
+    except roslib_electric.stacks.InvalidROSStackException as e:
+        if required:
+            raise
+
+def stack_file(stack, required=True):
+    """
+    @param stack: stack name
+    @type  stack: str
+    @param required: require that the directory exist
+    @type  required: bool
+    @return: path to manifest file of stack
+    @rtype:  str
+    @raise InvalidROSPkgException: if required is True and manifest file cannot be located
+    """
+    d = roslib_electric.stacks.get_stack_dir(stack)
+    return _stack_file_by_dir(d, required)
+        
+def parse_file(file):
+    """
+    Parse stack.xml file
+    @param file: stack.xml file path
+    @param file: str
+    @return: StackManifest instance
+    @rtype:  L{StackManifest}
+    """
+    return roslib_electric.manifestlib.parse_file(StackManifest(), file)
+
+def parse(string, filename='string'):
+    """
+    Parse stack.xml string contents
+    @param string: stack.xml contents
+    @type  string: str
+    @return: StackManifest instance
+    @rtype:  L{StackManifest}
+    """
+    s = roslib_electric.manifestlib.parse(StackManifest(), string, filename)
+    #TODO: validate
+    return s
diff -r cc8bd7a5eafb roslib_electric/src/roslib_electric/stacks.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/src/roslib_electric/stacks.py	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,343 @@
+#! /usr/bin/env python
+# Software License Agreement (BSD License)
+#
+# Copyright (c) 2008, Willow Garage, Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+#  * Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#  * Redistributions in binary form must reproduce the above
+#    copyright notice, this list of conditions and the following
+#    disclaimer in the documentation and/or other materials provided
+#    with the distribution.
+#  * Neither the name of Willow Garage, Inc. nor the names of its
+#    contributors may be used to endorse or promote products derived
+#    from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+# Revision $Id: stacks.py 14218 2011-07-11 20:39:24Z kwc $
+
+"""
+Python utilities for manipulating ROS Stacks.
+See: U{http://ros.org/wiki/Stacks}
+
+Warning: this API is still fairly experimental and incomplete.
+"""
+
+import os
+import sys
+import re
+
+import roslib_electric.exceptions
+import roslib_electric.packages
+import roslib_electric.stack_manifest
+from roslib_electric.rosenv import ROS_ROOT, ROS_PACKAGE_PATH
+
+STACK_FILE = 'stack.xml'
+ROS_STACK = 'ros'
+
+class ROSStackException(roslib_electric.exceptions.ROSLibException): pass
+class InvalidROSStackException(ROSStackException): pass
+
+def stack_of(pkg, env=None):
+    """
+    @param env: override environment variables
+    @type  env: {str: str}
+    @return: name of stack that pkg is in, or None if pkg is not part of a stack
+    @rtype: str
+    @raise roslib.packages.InvalidROSPkgException: if pkg cannot be located
+    """
+    if env is None:
+        env = os.environ
+    pkg_dir = roslib_electric.packages.get_pkg_dir(pkg, ros_root=env[ROS_ROOT], ros_package_path=env.get(ROS_PACKAGE_PATH, None))
+    d = pkg_dir
+    while d and os.path.dirname(d) != d:
+        stack_file = os.path.join(d, STACK_FILE)
+        if os.path.exists(stack_file):
+            #TODO: need to resolve issues regarding whether the
+            #stack.xml or the directory defines the stack name
+            return os.path.basename(d)
+        d = os.path.dirname(d)
+        
+def packages_of(stack, env=None):
+    """
+    @param env: override environment variables
+    @type  env: {str: str}
+    @return: name of packages that are part of stack
+    @rtype: [str]
+    @raise InvalidROSStackException: if stack cannot be located
+    @raise ValueError: if stack name is invalid
+    """
+    # record settings for error messages
+    if env is None:
+        env = os.environ
+    ros_root = env[ROS_ROOT]
+    ros_package_path = env.get(ROS_PACKAGE_PATH, '')
+    
+    if not stack:
+        raise ValueError("stack name not specified")
+    stack_dir = get_stack_dir(stack, env=env)
+    if stack_dir is None:
+        raise InvalidROSStackException("Cannot locate installation of stack %s. ROS_ROOT[%s] ROS_PACKAGE_PATH[%s]"%(stack, ros_root,ros_package_path))
+    # unary stack
+    if roslib_electric.packages.is_pkg_dir(stack_dir):
+        return [stack]
+    packages = []
+    l = [os.path.join(stack_dir, d) for d in os.listdir(stack_dir)]
+    # kwc: this really is just a 1-directory reimplementation of
+    # list_pkgs(). Should merge implementations, though have to deal
+    # with issues of cache, etc...
+    while l:
+        d = l.pop()
+        if os.path.isdir(d):
+            if roslib_electric.packages.is_pkg_dir(d):
+                p = os.path.basename(d)
+                # this is sometimes true if we've descended into a build directory
+                if not p in packages:
+                    packages.append(p)
+            elif os.path.exists(os.path.join(d, 'rospack_nosubdirs')):
+                # don't descend
+                pass
+            elif os.path.basename(d) not in ['build', '.svn', '.git']: #recurse
+                l.extend([os.path.join(d, e) for e in os.listdir(d)])
+    return packages
+    
+def get_stack_dir(stack, env=None):
+    """
+    Get the directory of a ROS stack. This will initialize an internal
+    cache and return cached results if possible.
+    
+    This routine is not thread-safe to os.environ changes.
+    
+    @param env: override environment variables
+    @type  env: {str: str}
+    @param stack: name of ROS stack to locate on disk
+    @type  stack: str
+    @return: directory of stack.
+    @rtype: str
+    @raise InvalidROSStackException: if stack cannot be located.
+    """
+    
+    # it's possible to get incorrect results from this cache
+    # implementation by manipulating the environment and calling this
+    # from multiple threads.  as that is an unusual use case and would
+    # require a slower implmentation, it's not supported. the
+    # interpretation of this routine is get_stack_dir for the
+    # environment this process was launched in.
+    global _dir_cache_marker 
+
+    if env is None:
+        env = os.environ
+    if stack in _dir_cache:
+        ros_root = env[ROS_ROOT]
+        ros_package_path = env.get(ROS_PACKAGE_PATH, '')
+
+        # we don't attempt to be thread-safe to environment changes,
+        # however we do need to be threadsafe to cache invalidation.
+        try:
+            if _dir_cache_marker == (ros_root, ros_package_path):
+                d = _dir_cache[stack]
+                if os.path.isfile(os.path.join(d, STACK_FILE)):
+                    return d
+                else:
+                    # invalidate the cache
+                    _dir_cache_marker = None
+                    _dir_cache.clear()
+        except KeyError:
+            pass
+    _update_stack_cache(env=env) #update cache
+    try:
+        val = _dir_cache[stack]
+    except KeyError:
+        raise InvalidROSStackException("Cannot location installation of stack %s. ROS_ROOT[%s] ROS_PACKAGE_PATH[%s]"%(stack, env[ROS_ROOT], env.get(ROS_PACKAGE_PATH, '')))
+    return val
+
+# rosstack directory cache
+_dir_cache = {}
+# stores ROS_ROOT, ROS_PACKAGE_PATH of _dir_cache
+_dir_cache_marker = None
+
+def _update_stack_cache(force=False, env=None):
+    """
+    Update _dir_cache if environment has changed since last cache build.
+    
+    @param env: override environment variables
+    @type  env: {str: str}
+    @param force: force cache rebuild regardless of environment variables
+    @type  force: bool
+    """
+    global _dir_cache_marker
+    if env is None:
+        env = os.environ
+    ros_root = env[ROS_ROOT]
+    ros_package_path = env.get(ROS_PACKAGE_PATH, '')
+    
+    if _dir_cache_marker == (ros_root, ros_package_path):
+        return
+    _dir_cache.clear()
+    _dir_cache_marker = ros_root, ros_package_path
+
+    pkg_dirs = roslib_electric.packages.get_package_paths(env=env)
+    # ros is assumed to be at ROS_ROOT
+    if os.path.exists(os.path.join(ros_root, 'stack.xml')):
+        _dir_cache['ros'] = ros_root
+        pkg_dirs.remove(ros_root)
+
+    # pass in accumulated stacks list to each call. This ensures
+    # precedence (i.e. that stacks first on pkg_dirs path win). 
+    stacks = []
+    for pkg_root in pkg_dirs:
+        # list_stacks_by_path will append list into stacks, so that
+        # each call accumulates in it.
+        list_stacks_by_path(pkg_root, stacks, cache=_dir_cache)
+    
+def list_stacks(env=None):
+    """
+    Get list of all ROS stacks. This uses an internal cache.
+
+    This routine is not thread-safe to os.environ changes.
+
+    @param env: override environment variables
+    @type  env: {str: str}
+    @return: complete list of stacks names in ROS environment
+    @rtype: [str]
+    """
+    _update_stack_cache(env=env)
+    return list(_dir_cache.keys()) #py3k
+
+def list_stacks_by_path(path, stacks=None, cache=None):
+    """
+    List ROS stacks within the specified path.
+
+    Optionally, a cache dictionary can be provided, which will be
+    updated with the stack->path mappings. list_stacks_by_path() does
+    NOT returned cached results -- it only updates the cache.
+    
+    @param path: path to list stacks in
+    @type  path: str
+    @param stacks: list of stacks to append to. If stack is
+      already present in stacks, it will be ignored.
+    @type  stacks: [str]
+    @param cache: (optional) stack path cache to update. Maps stack name to directory path.
+    @type  cache: {str: str}
+    @return: complete list of stack names in ROS environment. Same as stacks parameter.
+    @rtype: [str]
+    """
+    if stacks is None:
+        stacks = []
+    MANIFEST_FILE = roslib_electric.packages.MANIFEST_FILE
+    basename = os.path.basename
+    for d, dirs, files in os.walk(path, topdown=True):
+        if STACK_FILE in files:
+            stack = basename(d)
+            if stack not in stacks:
+                stacks.append(stack)
+                if cache is not None:
+                    cache[stack] = d
+            del dirs[:]
+            continue #leaf
+        elif MANIFEST_FILE in files:
+            del dirs[:]
+            continue #leaf     
+        elif 'rospack_nosubdirs' in files:
+            del dirs[:]
+            continue  #leaf
+        # remove hidden dirs (esp. .svn/.git)
+        [dirs.remove(di) for di in dirs if di[0] == '.']
+        for sub_d in dirs:
+            # followlinks=True only available in Python 2.6, so we
+            # have to implement manually
+            sub_p = os.path.join(d, sub_d)
+            if os.path.islink(sub_p):
+                stacks.extend(list_stacks_by_path(sub_p, cache=cache))
+    return stacks
+
+# #2022
+def expand_to_packages(names, env=None):
+    """
+    Expand names into a list of packages. Names can either be of packages or stacks.
+
+    @param names: names of stacks or packages
+    @type  names: [str]
+    @return: ([packages], [not_found]). expand_packages() returns two
+    lists. The first is of packages names. The second is a list of
+    names for which no matching stack or package was found. Lists may have duplicates.
+    @rtype: ([str], [str])
+    """
+    if type(names) not in [tuple, list]:
+        raise ValueError("names must be a list of strings")
+
+    # do full package list first. This forces an entire tree
+    # crawl. This is less efficient for a small list of names, but
+    # much more efficient for many names.
+    package_list = roslib_electric.packages.list_pkgs(env=env)
+    valid = []
+    invalid = []
+    for n in names:
+        if not n in package_list:
+            try:
+                valid.extend(roslib_electric.stacks.packages_of(n, env=env))
+            except roslib_electric.stacks.InvalidROSStackException as e:
+                invalid.append(n)
+        else:
+            valid.append(n)
+    return valid, invalid
+
+def get_stack_version(stack, env=None):
+    """
+    @param env: override environment variables
+    @type  env: {str: str}
+
+    @return: version number of stack, or None if stack is unversioned.
+    @rtype: str
+    """
+    return get_stack_version_by_dir(get_stack_dir(stack, env=env))
+
+def get_stack_version_by_dir(stack_dir):
+    """
+    Get stack version where stack_dir points to root directory of stack.
+    
+    @param env: override environment variables
+    @type  env: {str: str}
+
+    @return: version number of stack, or None if stack is unversioned.
+    @rtype: str
+    """
+    # REP 109: check for <version> tag first, then CMakeLists.txt
+    manifest_filename = os.path.join(stack_dir, STACK_FILE)
+    if os.path.isfile(manifest_filename):
+        m = roslib_electric.stack_manifest.parse_file(manifest_filename)
+        if m.version:
+            return m.version
+    
+    cmake_filename = os.path.join(stack_dir, 'CMakeLists.txt')
+    if os.path.isfile(cmake_filename):
+        with open(cmake_filename) as f:
+            return _get_cmake_version(f.read())
+    else:
+        return None
+
+def _get_cmake_version(text):
+    for l in text.split('\n'):
+        if l.strip().startswith('rosbuild_make_distribution'):
+            x_re = re.compile(r'[()]')
+            lsplit = x_re.split(l.strip())
+            if len(lsplit) < 2:
+                raise ReleaseException("couldn't find version number in CMakeLists.txt:\n\n%s"%l)
+            return lsplit[1]
diff -r cc8bd7a5eafb roslib_electric/src/roslib_electric/substitution_args.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/src/roslib_electric/substitution_args.py	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,267 @@
+# Software License Agreement (BSD License)
+#
+# Copyright (c) 2008, Willow Garage, Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+#  * Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#  * Redistributions in binary form must reproduce the above
+#    copyright notice, this list of conditions and the following
+#    disclaimer in the documentation and/or other materials provided
+#    with the distribution.
+#  * Neither the name of Willow Garage, Inc. nor the names of its
+#    contributors may be used to endorse or promote products derived
+#    from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+# Revision $Id: substitution_args.py 14215 2011-07-11 20:30:07Z kwc $
+
+"""
+Library for processing XML substitution args. This is currently used
+by roslaunch and xacro, but it is not yet a top-level ROS feature.
+"""
+
+import os
+
+try:
+    from cStringIO import StringIO # Python 2.x
+except ImportError:
+    from io import StringIO # Python 3.x
+
+import roslib_electric.exceptions
+import roslib_electric.names
+import roslib_electric.packages
+
+class SubstitutionException(roslib_electric.exceptions.ROSLibException):
+    """
+    Base class for exceptions in roslib.substitution_args routines
+    """
+    pass
+class ArgException(SubstitutionException):
+    """
+    Exception for missing $(arg) values
+    """
+    pass
+
+def _env(resolved, a, args, context):
+    """
+    process $(env) arg
+    @return: updated resolved argument
+    @rtype: str
+    @raise SubstitutionException: if arg invalidly specified
+    """
+    if len(args) != 1:
+        raise SubstitutionException("$(env var) command only accepts one argument [%s]"%a)
+    try:
+        return resolved.replace("$(%s)"%a, os.environ[args[0]])
+    except KeyError as e:
+        raise SubstitutionException("environment variable %s is not set"%str(e))
+
+def _optenv(resolved, a, args, context):
+    """
+    process $(optenv) arg
+    @return: updated resolved argument
+    @rtype: str
+    @raise SubstitutionException: if arg invalidly specified
+    """
+    if len(args) == 0:
+        raise SubstitutionException("$(optenv var) must specify an environment variable [%s]"%a)
+    if args[0] in os.environ:
+        return resolved.replace("$(%s)"%a, os.environ[args[0]])
+    elif len(args) > 1:
+        return resolved.replace("$(%s)"%a, ' '.join(args[1:]))
+    else:
+        return resolved.replace("$(%s)"%a, '')
+    
+def _anon(resolved, a, args, context):
+    """
+    process $(anon) arg
+    @return: updated resolved argument
+    @rtype: str
+    @raise SubstitutionException: if arg invalidly specified
+    """
+    # #1559 #1660
+    if len(args) == 0:
+        raise SubstitutionException("$(anon var) must specify a name [%s]"%a)
+    elif len(args) > 1:
+        raise SubstitutionException("$(anon var) may only specify one name [%s]"%a)
+    id = args[0]
+    if 'anon' not in context:
+        context['anon'] = {}
+    anon_context = context['anon']
+    if id in anon_context:
+        return resolved.replace("$(%s)"%a, anon_context[id])
+    else:
+        resolve_to = roslib_electric.names.anonymous_name(id)
+        anon_context[id] = resolve_to
+        return resolved.replace("$(%s)"%a, resolve_to)
+
+def _find(resolved, a, args, context):
+    """
+    process $(find) arg
+    @return: updated resolved argument
+    @rtype: str
+    @raise SubstitutionException: if arg invalidly specified
+    """
+    if len(args) != 1:
+        raise SubstitutionException("$(find pkg) command only accepts one argument [%s]"%a)
+    arg = "$(%s)"%a
+    sep = os.sep #set to var for easier testing
+
+    #Force / and \ file separators to the os-native
+    #convention. We replace everything from the end of the
+    #$(find) command to the next space. As we don't support
+    #filenames with spaces, this is dandy.
+    idx = resolved.find(arg)+len(arg)
+    endidx = resolved.find(' ', idx)
+    if endidx < 0:
+        endidx = len(resolved)
+    slash_orig = resolved[idx:endidx]
+    resolved = resolved.replace(slash_orig, slash_orig.replace('/', sep))
+    resolved = resolved.replace(slash_orig, slash_orig.replace('\\', sep))
+
+    return resolved[0:idx-len(arg)] + roslib_electric.packages.get_pkg_dir(args[0]) + resolved[idx:]
+    
+def _arg(resolved, a, args, context):
+    """
+    process $(arg) arg
+    
+    @return: updated resolved argument
+    @rtype: str
+    @raise ArgException: if arg invalidly specified
+    """
+    if len(args) == 0:
+        raise SubstitutionException("$(arg var) must specify an environment variable [%s]"%(a))
+    elif len(args) > 1:
+        raise SubstitutionException("$(arg var) may only specify one arg [%s]"%(a))
+    
+    if 'arg' not in context:
+        context['arg'] = {}
+    arg_context = context['arg']
+
+    arg_name = args[0]
+    if arg_name in arg_context:
+        arg_value = arg_context[arg_name]
+        return resolved.replace("$(%s)"%a, arg_value)
+    else:
+        raise ArgException(arg_name)
+
+
+def resolve_args(arg_str, context=None, resolve_anon=True):
+    """
+    Resolves substitution args (see wiki spec U{http://ros.org/wiki/roslaunch}).
+
+    @param arg_str: string to resolve zero or more substitution args
+        in. arg_str may be None, in which case resolve_args will
+        return None
+    @type  arg_str: str
+    @param context dict: (optional) dictionary for storing results of
+        the 'anon' and 'arg' substitution args. multiple calls to
+        resolve_args should use the same context so that 'anon'
+        substitions resolve consistently. If no context is provided, a
+        new one will be created for each call. Values for the 'arg'
+        context should be stored as a dictionary in the 'arg' key.
+    @type  context: dict
+    @param resolve_anon bool: If True (default), will resolve $(anon
+        foo). If false, will leave these args as-is.
+    @type  resolve_anon: bool
+
+    @return str: arg_str with substitution args resolved
+    @rtype:  str
+    @raise SubstitutionException: if there is an error resolving substitution args
+    """
+    if context is None:
+        context = {}
+    #parse found substitution args
+    if not arg_str:
+        return arg_str
+    valid = ['find', 'env', 'optenv', 'anon', 'arg']
+    # disabled 'export' due to lack of use and API change
+    resolved = arg_str
+    for a in _collect_args(arg_str):
+        splits = [s for s in a.split(' ') if s]
+        if not splits[0] in valid:
+            raise SubstitutionException("Unknown substitution command [%s]. Valid commands are %s"%(a, valid))
+        command = splits[0]
+        args = splits[1:]
+        if command == 'find':
+            resolved = _find(resolved, a, args, context)
+        elif command == 'env':
+            resolved = _env(resolved, a, args, context)
+        elif command == 'optenv':
+            resolved = _optenv(resolved, a, args, context)
+        elif command == 'anon' and resolve_anon:
+            resolved = _anon(resolved, a, args, context)
+        elif command == 'arg':
+            resolved = _arg(resolved, a, args, context)
+
+    return resolved
+
+_OUT  = 0
+_DOLLAR = 1
+_LP = 2
+_IN = 3
+def _collect_args(arg_str):
+    """
+    State-machine parser for resolve_args. Substitution args are of the form:
+    $(find rospy)/scripts/foo.py $(export some/attribute blar) non-relevant stuff
+    
+    @param arg_str: argument string to parse args from
+    @type  arg_str: str
+    @raise SubstitutionException: if args are invalidly specified
+    @return: list of arguments
+    @rtype: [str]
+    """
+    buff = StringIO()
+    args = []
+    state = _OUT
+    for c in arg_str:
+        # No escapes supported
+        if c == '$':
+            if state == _OUT:
+                state = _DOLLAR
+            elif state == _DOLLAR:
+                pass
+            else:
+                raise SubstitutionException("Dollar signs '$' cannot be inside of substitution args [%s]"%arg_str)
+        elif c == '(':
+            if state == _DOLLAR:
+                state = _LP
+            elif state != _OUT:
+                raise SubstitutionException("Invalid left parenthesis '(' in substitution args [%s]"%arg_str)
+        elif c == ')':
+            if state == _IN:
+                #save contents of collected buffer
+                args.append(buff.getvalue())
+                buff.truncate(0)
+                buff.seek(0)
+                state = _OUT
+            else:
+                state = _OUT
+        elif state == _DOLLAR:
+            # left paren must immediately follow dollar sign to enter _IN state
+            state = _OUT
+        elif state == _LP:
+            state = _IN
+
+        if state == _IN:
+            buff.write(c)
+    return args
+
+
diff -r cc8bd7a5eafb roslib_electric/src/roslib_electric/xmlrpc.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/roslib_electric/src/roslib_electric/xmlrpc.py	Tue Jun 12 15:24:41 2012 -0700
@@ -0,0 +1,278 @@
+# Software License Agreement (BSD License)
+#
+# Copyright (c) 2008, Willow Garage, Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+#  * Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#  * Redistributions in binary form must reproduce the above
+#    copyright notice, this list of conditions and the following
+#    disclaimer in the documentation and/or other materials provided
+#    with the distribution.
+#  * Neither the name of Willow Garage, Inc. nor the names of its
+#    contributors may be used to endorse or promote products derived
+#    from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+# Revision $Id: xmlrpc.py 15335 2011-11-07 20:42:37Z kwc $
+
+from __future__ import print_function
+
+"""
+Common XML-RPC for higher-level libraries running XML-RPC libraries in
+ROS. In particular, this library provides common handling for URI
+calculation based on ROS environment variables.
+
+The common entry point for most libraries is the L{XmlRpcNode} class.
+"""
+
+import logging
+import select
+import socket
+import string
+
+try:
+    import _thread
+except ImportError:
+    import thread as _thread
+
+import traceback
+
+try:
+    from xmlrpc.server import SimpleXMLRPCServer, SimpleXMLRPCRequestHandler #Python 3.x
+except ImportError:
+    from SimpleXMLRPCServer import SimpleXMLRPCServer #Python 2.x
+    from SimpleXMLRPCServer import SimpleXMLRPCRequestHandler #Python 2.x
+
+try:
+    import socketserver
+except ImportError:
+    import SocketServer as socketserver
+
+import roslib_electric.network
+import roslib_electric.exceptions
+
+def isstring(s):
+    """Small helper version to check an object is a string in a way that works
+    for both Python 2 and 3
+    """
+    try:
+        return isinstance(s, basestring)
+    except NameError:
+        return isinstance(s, str)
+
+class SilenceableXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
+    def log_message(self, format, *args):
+        if 0:
+            SimpleXMLRPCRequestHandler.log_message(self, format, *args)
+    
+class ThreadingXMLRPCServer(socketserver.ThreadingMixIn, SimpleXMLRPCServer):
+    """
+    Adds ThreadingMixin to SimpleXMLRPCServer to support multiple concurrent
+    requests via threading. Also makes logging toggleable.
+    """
+    def __init__(self, addr, log_requests=1):
+        """
+        Overrides SimpleXMLRPCServer to set option to allow_reuse_address.
+        """
+        # allow_reuse_address defaults to False in Python 2.4.  We set it 
+        # to True to allow quick restart on the same port.  This is equivalent 
+        # to calling setsockopt(SOL_SOCKET,SO_REUSEADDR,1)
+        self.allow_reuse_address = True
+        SimpleXMLRPCServer.__init__(self, addr, SilenceableXMLRPCRequestHandler, log_requests)
+
+    def handle_error(self, request, client_address):
+        """
+        override ThreadingMixin, which sends errors to stderr
+        """
+        if logging and traceback:
+            logger = logging.getLogger('xmlrpc')
+            if logger:
+                logger.error(traceback.format_exc())
+    
+class ForkingXMLRPCServer(socketserver.ForkingMixIn, SimpleXMLRPCServer):
+    """
+    Adds ThreadingMixin to SimpleXMLRPCServer to support multiple concurrent
+    requests via forking. Also makes logging toggleable.      
+    """
+    def __init__(self, addr, request_handler=SilenceableXMLRPCRequestHandler, log_requests=1):
+        SimpleXMLRPCServer.__init__(self, addr, request_handler, log_requests)
+    
+
+class XmlRpcHandler(object):
+    """
+    Base handler API for handlers used with XmlRpcNode. Public methods will be 
+    exported as XML RPC methods.
+    """
+
+    def _ready(self, uri):
+        """
+        callback into handler to inform it of XML-RPC URI
+        """
+        pass
+    
+class XmlRpcNode(object):
+    """
+    Generic XML-RPC node. Handles the additional complexity of binding
+    an XML-RPC server to an arbitrary port. 
+    XmlRpcNode is initialized when the uri field has a value.
+    """
+
+    def __init__(self, port=0, rpc_handler=None, on_run_error=None):
+        """
+        XML RPC Node constructor
+        @param port: port to use for starting XML-RPC API. Set to 0 or omit to bind to any available port.
+        @type  port: int
+        @param rpc_handler: XML-RPC API handler for node.
+        @type  rpc_handler: XmlRpcHandler
+        @param on_run_error: function to invoke if server.run() throws
+        Exception. Server always terminates if run() throws, but this
+        enables cleanup routines to be invoked if server goes down, as
+        well as include additional debugging.
+        @type  on_run_error: fn(Exception)
+        """
+        super(XmlRpcNode, self).__init__()
+
+        self.handler = rpc_handler
+        self.uri = None # initialize the property now so it can be tested against, will be filled in later
+        self.server = None
+        if port and isstring(port):
+            port = int(port)
+        self.port = port
+        self.is_shutdown = False
+        self.on_run_error = on_run_error
+
+    def shutdown(self, reason):
+        """
+        Terminate i/o connections for this server.
+        @param reason: human-readable debug string
+        @type  reason: str
+        """
+        self.is_shutdown = True
+        if self.server:
+            server = self.server
+            handler = self.handler
+            self.handler = self.server = self.port = self.uri = None
+            if handler:
+                handler._shutdown(reason)
+            if server:
+                server.socket.close()
+                server.server_close()
+                
+    def start(self):
+        """
+        Initiate a thread to run the XML RPC server. Uses thread.start_new_thread.
+        """
+        _thread.start_new_thread(self.run, ())
+
+    def set_uri(self, uri):
+        """
+        Sets the XML-RPC URI. Defined as a separate method as a hood
+        for subclasses to bootstrap initialization. Should not be called externally.
+        @param uri: XMLRPC URI.
+        @type  uri: str
+        """
+        self.uri = uri
+        
+    def run(self):
+        try:
+            self._run()
+        except Exception as e:
+            if self.is_shutdown:
+                pass
+            elif self.on_run_error is not None:
+               self.on_run_error(e)
+            else:
+                raise
+
+    def _run(self):
+        """
+        Main processing thread body.
+        @raise socket.error: If server cannot bind
+        @raise roslib_electric.exceptions.ROSLibException: If unknown error occurs
+        """
+        logger = logging.getLogger('xmlrpc')            
+        try:
+            log_requests = 0
+            port = self.port or 0 #0 = any
+
+            bind_address = roslib_electric.network.get_bind_address()
+            logger.info("XML-RPC server binding to %s"%bind_address)
+            
+            self.server = ThreadingXMLRPCServer((bind_address, port), log_requests)
+            self.port = self.server.server_address[1] #set the port to whatever server bound to
+            if not self.port:
+                self.port = self.server.socket.getsockname()[1] #Python 2.4
+            if not self.port:
+                raise roslib_electric.exceptions.ROSLibException("Unable to retrieve local address binding")
+
+            # #528: semi-complicated logic for determining XML-RPC URI
+            # - if ROS_IP/ROS_HOSTNAME is set, use that address
+            # - if the hostname returns a non-localhost value, use that
+            # - use whatever roslib_electric.network.get_local_address() returns
+            uri = None
+            override = roslib_electric.network.get_address_override()
+            if override:
+                uri = 'http://%s:%s/'%(override, self.port)
+            else:
+                try:
+                    hostname = socket.gethostname()
+                    if hostname and not hostname == 'localhost' and not hostname.startswith('127.'):
+                        uri = 'http://%s:%s/'%(hostname, self.port)
+                except:
+                    pass
+            if not uri:
+                uri = 'http://%s:%s/'%(roslib_electric.network.get_local_address(), self.port)
+            self.set_uri(uri)
+            
+            #print "... started XML-RPC Server", self.uri
+            logger.info("Started XML-RPC server [%s]", self.uri)
+
+            self.server.register_multicall_functions()
+            self.server.register_instance(self.handler)
+
+        except socket.error as e:
+            (n, errstr) = e
+            if n == 98:
+                msg = "ERROR: Unable to start XML-RPC server, port %s is already in use"%self.port
+            else:
+                msg = "ERROR: Unable to start XML-RPC server: %s"%errstr                
+            logger.error(msg)
+            print(msg)
+            raise #let higher level catch this
+
+        if self.handler is not None:
+            self.handler._ready(self.uri)
+        logger.info("xml rpc node: starting XML-RPC server")
+        while not self.is_shutdown:
+            try:
+                self.server.serve_forever()
+            except (IOError, select.error) as e:
+                (errno, errstr) = e
+                # check for interrupted call, which can occur if we're
+                # embedded in a program using signals.  All other
+                # exceptions break _run.
+                if self.is_shutdown:
+                    pass
+                elif errno != 4:
+                    self.is_shutdown = True
+                    logger.error("serve forever IOError: %s, %s"%(errno, errstr))
+                    
+
+
